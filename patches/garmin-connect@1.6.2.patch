diff --git a/dist/common/HttpClient.d.ts b/dist/common/HttpClient.d.ts
deleted file mode 100644
index 5eae03d0f0eb23c4c61133d30c1708a0075b9d04..0000000000000000000000000000000000000000
diff --git a/dist/common/HttpClient.js b/dist/common/HttpClient.js
deleted file mode 100644
index 7933f7ba1896fa22b4f5c54685ba0447d8a7e93c..0000000000000000000000000000000000000000
diff --git a/dist/common/HttpClient.js.map b/dist/common/HttpClient.js.map
deleted file mode 100644
index 826b5b45fcc42cd1a18d10847316c50a84795e52..0000000000000000000000000000000000000000
diff --git a/dist/garmin/GarminConnect.d.ts b/dist/garmin/GarminConnect.d.ts
deleted file mode 100644
index 52b0bb71cc006832a999a33c99b01d3d1c5cb4cf..0000000000000000000000000000000000000000
diff --git a/dist/garmin/GarminConnect.js b/dist/garmin/GarminConnect.js
deleted file mode 100644
index dc4057b5667ddba1589173dfa864b6e2dc525cd8..0000000000000000000000000000000000000000
diff --git a/dist/garmin/GarminConnect.js.map b/dist/garmin/GarminConnect.js.map
deleted file mode 100644
index 56b49805f0cf0d5cb2cd427cae540ec100e5562d..0000000000000000000000000000000000000000
diff --git a/dist/garmin/UrlClass.d.ts b/dist/garmin/UrlClass.d.ts
deleted file mode 100644
index 97f95a1e0f6da5154d992c86e4deefc0cc62ab5d..0000000000000000000000000000000000000000
diff --git a/dist/garmin/UrlClass.js b/dist/garmin/UrlClass.js
deleted file mode 100644
index 12234e37ce2ff19a4dcdb79403285310fc9af5f6..0000000000000000000000000000000000000000
diff --git a/dist/garmin/UrlClass.js.map b/dist/garmin/UrlClass.js.map
deleted file mode 100644
index 5ca91ae328ef60a7ad11420cb375bde40a43f1a6..0000000000000000000000000000000000000000
diff --git a/dist/garmin/common/DateUtils.d.ts b/dist/garmin/common/DateUtils.d.ts
deleted file mode 100644
index b081c97aee16b75693790228f9f348490f2b0857..0000000000000000000000000000000000000000
diff --git a/dist/garmin/common/DateUtils.js b/dist/garmin/common/DateUtils.js
deleted file mode 100644
index 33d081b9c45ab75048f12c20328cfec03c1fb2de..0000000000000000000000000000000000000000
diff --git a/dist/garmin/common/DateUtils.js.map b/dist/garmin/common/DateUtils.js.map
deleted file mode 100644
index 5a3a065b850b8245dfd6cecfe2aab11df63738b4..0000000000000000000000000000000000000000
diff --git a/dist/garmin/common/HydrationUtils.d.ts b/dist/garmin/common/HydrationUtils.d.ts
deleted file mode 100644
index eff4dc4ef4b76a20252fa7226a3b62f484bf667e..0000000000000000000000000000000000000000
diff --git a/dist/garmin/common/HydrationUtils.js b/dist/garmin/common/HydrationUtils.js
deleted file mode 100644
index adb9813a1fea4ba23cdfa814ab2cb0ef6bea07e1..0000000000000000000000000000000000000000
diff --git a/dist/garmin/common/HydrationUtils.js.map b/dist/garmin/common/HydrationUtils.js.map
deleted file mode 100644
index 2309be8181cc67ebf014aa275ee11339e046f54d..0000000000000000000000000000000000000000
diff --git a/dist/garmin/common/WeightUtils.d.ts b/dist/garmin/common/WeightUtils.d.ts
deleted file mode 100644
index 290f152b0b5591e9cf872737be3fe8a4d055d510..0000000000000000000000000000000000000000
diff --git a/dist/garmin/common/WeightUtils.js b/dist/garmin/common/WeightUtils.js
deleted file mode 100644
index fb569a54d2cee584316aa7625a3b4172d38dee2e..0000000000000000000000000000000000000000
diff --git a/dist/garmin/common/WeightUtils.js.map b/dist/garmin/common/WeightUtils.js.map
deleted file mode 100644
index a36bbc5bcc7dc25857b2d846b9e96f3b4beaa925..0000000000000000000000000000000000000000
diff --git a/dist/garmin/types/activity.d.ts b/dist/garmin/types/activity.d.ts
deleted file mode 100644
index fc9b0a6d2247f8912dfa71d101cb7ae6abc8927e..0000000000000000000000000000000000000000
diff --git a/dist/garmin/types/activity.js b/dist/garmin/types/activity.js
deleted file mode 100644
index e8e201728c16f3cf31961124cfa40b953d1d4abe..0000000000000000000000000000000000000000
diff --git a/dist/garmin/types/activity.js.map b/dist/garmin/types/activity.js.map
deleted file mode 100644
index 9589abaea2c536641ab7fb1f63a2af5ed7db45f9..0000000000000000000000000000000000000000
diff --git a/dist/garmin/types/golf.d.ts b/dist/garmin/types/golf.d.ts
deleted file mode 100644
index 3f1c86c0da303f4be10f4e1a4b2d09e899c61166..0000000000000000000000000000000000000000
diff --git a/dist/garmin/types/golf.js b/dist/garmin/types/golf.js
deleted file mode 100644
index 1185dccaf8979432d5afee225b915c4efa1378a1..0000000000000000000000000000000000000000
diff --git a/dist/garmin/types/golf.js.map b/dist/garmin/types/golf.js.map
deleted file mode 100644
index 9089253e3aa4756c008b0adc8c7345128a877b7d..0000000000000000000000000000000000000000
diff --git a/dist/garmin/types/heartrate.d.ts b/dist/garmin/types/heartrate.d.ts
deleted file mode 100644
index 960b14b0b8dd0be30cb3c2538ae00aa40a86f488..0000000000000000000000000000000000000000
diff --git a/dist/garmin/types/heartrate.js b/dist/garmin/types/heartrate.js
deleted file mode 100644
index 46eaa699f8cd57591c7aea1a75b6ea0abf43f6fb..0000000000000000000000000000000000000000
diff --git a/dist/garmin/types/heartrate.js.map b/dist/garmin/types/heartrate.js.map
deleted file mode 100644
index b39df29885db75881a2f2bc8601a7471aa30d038..0000000000000000000000000000000000000000
diff --git a/dist/garmin/types/hydration.d.ts b/dist/garmin/types/hydration.d.ts
deleted file mode 100644
index 64b9cb505d9a720b661fa837814789c2970dcc72..0000000000000000000000000000000000000000
diff --git a/dist/garmin/types/hydration.js b/dist/garmin/types/hydration.js
deleted file mode 100644
index db1e88b319a9db42b1bf0da172d75da51e377f36..0000000000000000000000000000000000000000
diff --git a/dist/garmin/types/hydration.js.map b/dist/garmin/types/hydration.js.map
deleted file mode 100644
index 8ef3e0f2ce1f8da509cffaf57637f0c74b51c702..0000000000000000000000000000000000000000
diff --git a/dist/garmin/types/index.d.ts b/dist/garmin/types/index.d.ts
deleted file mode 100644
index aca6597f74a2622be6786b8d0eb7939d8584a42a..0000000000000000000000000000000000000000
diff --git a/dist/garmin/types/index.js b/dist/garmin/types/index.js
deleted file mode 100644
index ae943e35bedfd2750820645aff6d4875ce919d0e..0000000000000000000000000000000000000000
diff --git a/dist/garmin/types/index.js.map b/dist/garmin/types/index.js.map
deleted file mode 100644
index 986c461fa934451b20d725d4814a4598d3853bdc..0000000000000000000000000000000000000000
diff --git a/dist/garmin/types/sleep.d.ts b/dist/garmin/types/sleep.d.ts
deleted file mode 100644
index 52a287c001e3cd5cf2eac990b1ae4cd52e771ce4..0000000000000000000000000000000000000000
diff --git a/dist/garmin/types/sleep.js b/dist/garmin/types/sleep.js
deleted file mode 100644
index decc1e7068d753445fedbc4537577c0d3e8c7c61..0000000000000000000000000000000000000000
diff --git a/dist/garmin/types/sleep.js.map b/dist/garmin/types/sleep.js.map
deleted file mode 100644
index 7eb2e569ae49df1bb103ddc67189495cdcd92b05..0000000000000000000000000000000000000000
diff --git a/dist/garmin/types/weight.d.ts b/dist/garmin/types/weight.d.ts
deleted file mode 100644
index c2cb7c9f853eea33c0a863abedbf48e15fa1ab28..0000000000000000000000000000000000000000
diff --git a/dist/garmin/types/weight.js b/dist/garmin/types/weight.js
deleted file mode 100644
index 403329488db41feeac6c8c612ac329aac0c1f266..0000000000000000000000000000000000000000
diff --git a/dist/garmin/types/weight.js.map b/dist/garmin/types/weight.js.map
deleted file mode 100644
index 87cf6fad6cab01e692b2ec0258b102024046beb6..0000000000000000000000000000000000000000
diff --git a/dist/garmin/types.d.ts b/dist/garmin/types.d.ts
deleted file mode 100644
index c9fd11d8ec0dfc5d450070e5413c918676df38ea..0000000000000000000000000000000000000000
diff --git a/dist/garmin/types.js b/dist/garmin/types.js
deleted file mode 100644
index 6407e7b87793e5705511fbc0b6ee70e2de617437..0000000000000000000000000000000000000000
diff --git a/dist/garmin/types.js.map b/dist/garmin/types.js.map
deleted file mode 100644
index 3eff8151ef0cc7b069862e1a6ee05a6eedbb2f12..0000000000000000000000000000000000000000
diff --git a/dist/garmin/workouts/Running.d.ts b/dist/garmin/workouts/Running.d.ts
deleted file mode 100644
index 1e876d6676a4b9b88fd46ba3c10e2d74309adba9..0000000000000000000000000000000000000000
diff --git a/dist/garmin/workouts/Running.js b/dist/garmin/workouts/Running.js
deleted file mode 100644
index 560633eabb0d6ff8559534b4b5efe95df6692ff0..0000000000000000000000000000000000000000
diff --git a/dist/garmin/workouts/Running.js.map b/dist/garmin/workouts/Running.js.map
deleted file mode 100644
index 9df3a4ca31c8063aaaa5299b5986946f4cd3681a..0000000000000000000000000000000000000000
diff --git a/dist/garmin/workouts/templates/RunningTemplate.d.ts b/dist/garmin/workouts/templates/RunningTemplate.d.ts
deleted file mode 100644
index 132d3f0b7437ee685cf8bf9bc6d004de51269112..0000000000000000000000000000000000000000
diff --git a/dist/garmin/workouts/templates/RunningTemplate.js b/dist/garmin/workouts/templates/RunningTemplate.js
deleted file mode 100644
index 60b08a861bbcfdc704ec2246080b125318fcaf78..0000000000000000000000000000000000000000
diff --git a/dist/garmin/workouts/templates/RunningTemplate.js.map b/dist/garmin/workouts/templates/RunningTemplate.js.map
deleted file mode 100644
index 1943bb64881b6a4f0abaf5dc1984f5b812c45b61..0000000000000000000000000000000000000000
diff --git a/dist/index.cjs b/dist/index.cjs
new file mode 100644
index 0000000000000000000000000000000000000000..1e47f6c3e743fdcdcf38ad745e3ce5d49782e3c4
--- /dev/null
+++ b/dist/index.cjs
@@ -0,0 +1,1038 @@
+"use strict";
+var __create = Object.create;
+var __defProp = Object.defineProperty;
+var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
+var __getOwnPropNames = Object.getOwnPropertyNames;
+var __getProtoOf = Object.getPrototypeOf;
+var __hasOwnProp = Object.prototype.hasOwnProperty;
+var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
+var __export = (target, all) => {
+  for (var name in all)
+    __defProp(target, name, { get: all[name], enumerable: true });
+};
+var __copyProps = (to, from, except, desc) => {
+  if (from && typeof from === "object" || typeof from === "function") {
+    for (let key of __getOwnPropNames(from))
+      if (!__hasOwnProp.call(to, key) && key !== except)
+        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
+  }
+  return to;
+};
+var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
+  // If the importer is in node compatibility mode or this is not an ESM
+  // file that has been converted to a CommonJS file using a Babel-
+  // compatible transform (i.e. "__esModule" has not been set), then set
+  // "default" to the CommonJS "module.exports" for node compatibility.
+  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
+  mod
+));
+var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
+
+// src/index.ts
+var index_exports = {};
+__export(index_exports, {
+  ActivitySubType: () => ActivitySubType,
+  ActivityType: () => ActivityType,
+  GarminConnect: () => GarminConnect,
+  GearStatus: () => GearStatus
+});
+module.exports = __toCommonJS(index_exports);
+
+// src/garmin/GarminConnect.ts
+var import_app_root_path = __toESM(require("app-root-path"), 1);
+var import_form_data2 = __toESM(require("form-data"), 1);
+var import_lodash2 = __toESM(require("lodash"), 1);
+var import_luxon2 = require("luxon");
+var fs = __toESM(require("fs"), 1);
+var path = __toESM(require("path"), 1);
+
+// src/common/HttpClient.ts
+var import_axios = __toESM(require("axios"), 1);
+var import_form_data = __toESM(require("form-data"), 1);
+var import_lodash = __toESM(require("lodash"), 1);
+var import_luxon = require("luxon");
+var import_oauth_1 = __toESM(require("oauth-1.0a"), 1);
+var import_qs = __toESM(require("qs"), 1);
+var import_crypto = require("crypto");
+var CSRF_RE = /name="_csrf"\s+value="(.+?)"/;
+var TICKET_RE = /ticket=([^"]+)"/;
+var ACCOUNT_LOCKED_RE = /var statuss*=s*"([^"]*)"/;
+var PAGE_TITLE_RE = /<title>([^<]*)<\/title>/;
+var USER_AGENT_CONNECTMOBILE = "com.garmin.android.apps.connectmobile";
+var USER_AGENT_BROWSER = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36";
+var OAUTH_CONSUMER_URL = "https://thegarth.s3.amazonaws.com/oauth_consumer.json";
+var isRefreshing = false;
+var refreshSubscribers = [];
+var HttpClient = class {
+  static {
+    __name(this, "HttpClient");
+  }
+  constructor(url) {
+    this.url = url;
+    this.client = import_axios.default.create();
+    this.client.interceptors.response.use(
+      (response) => response,
+      async (error) => {
+        const originalRequest = error.config;
+        if (error?.response?.status === 401 && !originalRequest?._retry) {
+          if (!this.oauth2Token) {
+            return;
+          }
+          if (isRefreshing) {
+            try {
+              const token = await new Promise((resolve) => {
+                refreshSubscribers.push((token2) => {
+                  resolve(token2);
+                });
+              });
+              originalRequest.headers.Authorization = `Bearer ${token}`;
+              return this.client(originalRequest);
+            } catch (err) {
+              console.log("err:", err);
+              return Promise.reject(err);
+            }
+          }
+          originalRequest._retry = true;
+          isRefreshing = true;
+          console.log("interceptors: refreshOauth2Token start");
+          await this.refreshOauth2Token();
+          console.log("interceptors: refreshOauth2Token end");
+          isRefreshing = false;
+          refreshSubscribers.forEach((subscriber) => subscriber(this.oauth2Token.access_token));
+          refreshSubscribers = [];
+          originalRequest.headers.Authorization = `Bearer ${this.oauth2Token.access_token}`;
+          return this.client(originalRequest);
+        }
+        if (import_axios.default.isAxiosError(error)) {
+          if (error?.response) this.handleError(error?.response);
+        }
+        throw error;
+      }
+    );
+    this.client.interceptors.request.use(async (config2) => {
+      if (this.oauth2Token) {
+        config2.headers.Authorization = `Bearer ${this.oauth2Token.access_token}`;
+      }
+      return config2;
+    });
+  }
+  async fetchOauthConsumer() {
+    const response = await import_axios.default.get(OAUTH_CONSUMER_URL);
+    this.OAUTH_CONSUMER = {
+      key: response.data.consumer_key,
+      secret: response.data.consumer_secret
+    };
+  }
+  async checkTokenVaild() {
+    if (this.oauth2Token) {
+      if (this.oauth2Token.expires_at < import_luxon.DateTime.now().toSeconds()) {
+        console.error("Token expired!");
+        await this.refreshOauth2Token();
+      }
+    }
+  }
+  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
+  async get(url, config2) {
+    const response = await this.client.get(url, config2);
+    return response?.data;
+  }
+  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
+  async post(url, data, config2) {
+    const response = await this.client.post(url, data, config2);
+    return response?.data;
+  }
+  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
+  async put(url, data, config2) {
+    const response = await this.client.put(url, data, config2);
+    return response?.data;
+  }
+  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
+  async delete(url, config2) {
+    const response = await this.client.post(url, null, {
+      ...config2,
+      headers: {
+        ...config2?.headers,
+        "X-Http-Method-Override": "DELETE"
+      }
+    });
+    return response?.data;
+  }
+  setCommonHeader(headers) {
+    import_lodash.default.each(headers, (headerValue, key) => {
+      this.client.defaults.headers.common[key] = headerValue;
+    });
+  }
+  handleError(response) {
+    this.handleHttpError(response);
+  }
+  handleHttpError(response) {
+    const { status, statusText, data } = response;
+    const msg = `ERROR: (${status}), ${statusText}, ${JSON.stringify(data)}`;
+    console.error(msg);
+    throw new Error(msg);
+  }
+  /**
+   * Login to Garmin Connect
+   * @param username
+   * @param password
+   * @returns {Promise<HttpClient>}
+   */
+  async login(username, password) {
+    await this.fetchOauthConsumer();
+    const ticket = await this.getLoginTicket(username, password);
+    const oauth1 = await this.getOauth1Token(ticket);
+    await this.exchange(oauth1);
+    return this;
+  }
+  async getLoginTicket(username, password) {
+    const step1Params = {
+      clientId: "GarminConnect",
+      locale: "en",
+      service: this.url.GC_MODERN
+    };
+    const step1Url = `${this.url.GARMIN_SSO_EMBED}?${import_qs.default.stringify(step1Params)}`;
+    await this.client.get(step1Url);
+    const step2Params = {
+      id: "gauth-widget",
+      embedWidget: true,
+      locale: "en",
+      gauthHost: this.url.GARMIN_SSO_EMBED
+    };
+    const step2Url = `${this.url.SIGNIN_URL}?${import_qs.default.stringify(step2Params)}`;
+    const step2Result = await this.get(step2Url);
+    const csrfRegResult = CSRF_RE.exec(step2Result);
+    if (!csrfRegResult) {
+      throw new Error("login - csrf not found");
+    }
+    const csrf_token = csrfRegResult[1];
+    const signinParams = {
+      id: "gauth-widget",
+      embedWidget: true,
+      clientId: "GarminConnect",
+      locale: "en",
+      gauthHost: this.url.GARMIN_SSO_EMBED,
+      service: this.url.GARMIN_SSO_EMBED,
+      source: this.url.GARMIN_SSO_EMBED,
+      redirectAfterAccountLoginUrl: this.url.GARMIN_SSO_EMBED,
+      redirectAfterAccountCreationUrl: this.url.GARMIN_SSO_EMBED
+    };
+    const step3Url = `${this.url.SIGNIN_URL}?${import_qs.default.stringify(signinParams)}`;
+    const step3Form = new import_form_data.default();
+    step3Form.append("username", username);
+    step3Form.append("password", password);
+    step3Form.append("embed", "true");
+    step3Form.append("_csrf", csrf_token);
+    const step3Result = await this.post(step3Url, step3Form, {
+      headers: {
+        "Content-Type": "application/x-www-form-urlencoded",
+        Dnt: 1,
+        Origin: this.url.GARMIN_SSO_ORIGIN,
+        Referer: this.url.SIGNIN_URL,
+        "User-Agent": USER_AGENT_BROWSER
+      }
+    });
+    this.handleAccountLocked(step3Result);
+    this.handlePageTitle(step3Result);
+    this.handleMFA(step3Result);
+    const ticketRegResult = TICKET_RE.exec(step3Result);
+    if (!ticketRegResult) {
+      throw new Error("login failed (Ticket not found or MFA), please check username and password");
+    }
+    const ticket = ticketRegResult[1];
+    return ticket;
+  }
+  // TODO: Handle MFA
+  handleMFA(htmlStr) {
+  }
+  // TODO: Handle Phone number
+  handlePageTitle(htmlStr) {
+    const pageTitileRegResult = PAGE_TITLE_RE.exec(htmlStr);
+    if (pageTitileRegResult) {
+      const title = pageTitileRegResult[1];
+      console.log("login page title:", title);
+      if (import_lodash.default.includes(title, "Update Phone Number")) {
+        throw new Error(
+          "login failed (Update Phone number), please update your phone number, currently I don't know where to update it"
+        );
+      }
+    }
+  }
+  handleAccountLocked(htmlStr) {
+    const accountLockedRegResult = ACCOUNT_LOCKED_RE.exec(htmlStr);
+    if (accountLockedRegResult) {
+      const msg = accountLockedRegResult[1];
+      console.error(msg);
+      throw new Error("login failed (AccountLocked), please open connect web page to unlock your account");
+    }
+  }
+  async refreshOauth2Token() {
+    if (!this.OAUTH_CONSUMER) {
+      await this.fetchOauthConsumer();
+    }
+    if (!this.oauth2Token || !this.oauth1Token) {
+      throw new Error("No Oauth2Token or Oauth1Token");
+    }
+    const oauth1 = {
+      // biome-ignore lint/style/noNonNullAssertion: <explanation>
+      oauth: this.getOauthClient(this.OAUTH_CONSUMER),
+      token: this.oauth1Token
+    };
+    await this.exchange(oauth1);
+    console.log("Oauth2 token refreshed!");
+  }
+  async getOauth1Token(ticket) {
+    if (!this.OAUTH_CONSUMER) {
+      throw new Error("No OAUTH_CONSUMER");
+    }
+    const params = {
+      ticket,
+      "login-url": this.url.GARMIN_SSO_EMBED,
+      "accepts-mfa-tokens": true
+    };
+    const url = `${this.url.OAUTH_URL}/preauthorized?${import_qs.default.stringify(params)}`;
+    const oauth = this.getOauthClient(this.OAUTH_CONSUMER);
+    const step4RequestData = {
+      url,
+      method: "GET"
+    };
+    const headers = oauth.toHeader(oauth.authorize(step4RequestData));
+    const response = await this.get(url, {
+      headers: {
+        ...headers,
+        "User-Agent": USER_AGENT_CONNECTMOBILE
+      }
+    });
+    const token = import_qs.default.parse(response);
+    this.oauth1Token = token;
+    return { token, oauth };
+  }
+  getOauthClient(consumer) {
+    const oauth = new import_oauth_1.default({
+      consumer,
+      signature_method: "HMAC-SHA1",
+      hash_function(base_string, key) {
+        return (0, import_crypto.createHmac)("sha1", key).update(base_string).digest("base64");
+      }
+    });
+    return oauth;
+  }
+  //
+  async exchange(oauth1) {
+    const token = {
+      key: oauth1.token.oauth_token,
+      secret: oauth1.token.oauth_token_secret
+    };
+    const baseUrl = `${this.url.OAUTH_URL}/exchange/user/2.0`;
+    const requestData = {
+      url: baseUrl,
+      method: "POST",
+      data: null
+    };
+    const step5AuthData = oauth1.oauth.authorize(requestData, token);
+    const url = `${baseUrl}?${import_qs.default.stringify(step5AuthData)}`;
+    this.oauth2Token = void 0;
+    const response = await this.post(url, null, {
+      headers: {
+        "User-Agent": USER_AGENT_CONNECTMOBILE,
+        "Content-Type": "application/x-www-form-urlencoded"
+      }
+    });
+    this.oauth2Token = this.setOauth2TokenExpiresAt(response);
+  }
+  setOauth2TokenExpiresAt(token) {
+    token.last_update_date = import_luxon.DateTime.now().toLocal().toString();
+    token.expires_date = import_luxon.DateTime.fromSeconds(import_luxon.DateTime.now().toSeconds() + token.expires_in).toLocal().toString();
+    token.expires_at = import_luxon.DateTime.now().toSeconds() + token.expires_in;
+    token.refresh_token_expires_at = import_luxon.DateTime.now().toSeconds() + token.refresh_token_expires_in;
+    return token;
+  }
+};
+
+// src/utils.ts
+var import_node_fs = require("fs");
+var checkIsDirectory = /* @__PURE__ */ __name((filePath) => {
+  return (0, import_node_fs.existsSync)(filePath) && (0, import_node_fs.lstatSync)(filePath).isDirectory();
+}, "checkIsDirectory");
+var createDirectory = /* @__PURE__ */ __name((directoryPath) => {
+  (0, import_node_fs.mkdirSync)(directoryPath);
+}, "createDirectory");
+var writeToFile = /* @__PURE__ */ __name((filePath, data) => {
+  (0, import_node_fs.writeFileSync)(filePath, data);
+}, "writeToFile");
+
+// src/garmin/UrlClass.ts
+var UrlClass = class {
+  static {
+    __name(this, "UrlClass");
+  }
+  constructor(domain = "garmin.com") {
+    this.domain = domain;
+    this.GC_MODERN = `https://connect.${this.domain}/modern`;
+    this.GARMIN_SSO_ORIGIN = `https://sso.${this.domain}`;
+    this.GC_API = `https://connectapi.${this.domain}`;
+  }
+  get GARMIN_SSO() {
+    return `${this.GARMIN_SSO_ORIGIN}/sso`;
+  }
+  get GARMIN_SSO_EMBED() {
+    return `${this.GARMIN_SSO_ORIGIN}/sso/embed`;
+  }
+  get BASE_URL() {
+    return `${this.GC_MODERN}/proxy`;
+  }
+  get SIGNIN_URL() {
+    return `${this.GARMIN_SSO}/signin`;
+  }
+  get LOGIN_URL() {
+    return `${this.GARMIN_SSO}/login`;
+  }
+  get OAUTH_URL() {
+    return `${this.GC_API}/oauth-service/oauth`;
+  }
+  get USER_SETTINGS() {
+    return `${this.GC_API}/userprofile-service/userprofile/user-settings/`;
+  }
+  get USER_PROFILE() {
+    return `${this.GC_API}/userprofile-service/socialProfile`;
+  }
+  get ACTIVITIES() {
+    return `${this.GC_API}/activitylist-service/activities/search/activities`;
+  }
+  get ACTIVITY() {
+    return `${this.GC_API}/activity-service/activity/`;
+  }
+  get STAT_ACTIVITIES() {
+    return `${this.GC_API}/fitnessstats-service/activity`;
+  }
+  get CREATE_GEAR() {
+    return `${this.GC_API}/gear-service/gear`;
+  }
+  get ACTIVITY_GEAR() {
+    return `${this.GC_API}/gear-service/gear/filterGear`;
+  }
+  GEAR_DATA(gearId) {
+    return `${this.GC_API}/gear-service/gear/${gearId}`;
+  }
+  ACTIVITY_GEAR_LINK(gearId, activityId) {
+    return `${this.GC_API}/gear-service/gear/link/${gearId}/activity/${activityId}`;
+  }
+  ACTIVITY_GEAR_UNLINK(gearId, activityId) {
+    return `${this.GC_API}/gear-service/gear/unlink/${gearId}/activity/${activityId}`;
+  }
+  get DOWNLOAD_ZIP() {
+    return `${this.GC_API}/download-service/files/activity/`;
+  }
+  get DOWNLOAD_GPX() {
+    return `${this.GC_API}/download-service/export/gpx/activity/`;
+  }
+  get DOWNLOAD_TCX() {
+    return `${this.GC_API}/download-service/export/tcx/activity/`;
+  }
+  get DOWNLOAD_KML() {
+    return `${this.GC_API}/download-service/export/kml/activity/`;
+  }
+  UPLOAD(format) {
+    return `${this.GC_API}/upload-service/upload/.${format}`;
+  }
+  UPLOAD_ACTIVITY_STATUS(uploadTime, activityId) {
+    return `${this.GC_API}/activity-service/activity/status/${uploadTime}/${activityId}`;
+  }
+  get IMPORT_DATA() {
+    return `${this.GC_API}/modern/import-data`;
+  }
+  get DAILY_STEPS() {
+    return `${this.GC_API}/usersummary-service/stats/steps/daily/`;
+  }
+  get DAILY_SLEEP() {
+    return `${this.GC_API}/sleep-service/sleep/dailySleepData`;
+  }
+  get DAILY_WEIGHT() {
+    return `${this.GC_API}/weight-service/weight/dayview`;
+  }
+  get UPDATE_WEIGHT() {
+    return `${this.GC_API}/weight-service/user-weight`;
+  }
+  get DAILY_HYDRATION() {
+    return `${this.GC_API}/usersummary-service/usersummary/hydration/allData`;
+  }
+  get HYDRATION_LOG() {
+    return `${this.GC_API}/usersummary-service/usersummary/hydration/log`;
+  }
+  get GOLF_SCORECARD_SUMMARY() {
+    return `${this.GC_API}/gcs-golfcommunity/api/v2/scorecard/summary`;
+  }
+  get GOLF_SCORECARD_DETAIL() {
+    return `${this.GC_API}/gcs-golfcommunity/api/v2/scorecard/detail`;
+  }
+  get DAILY_HEART_RATE() {
+    return `${this.GC_API}/wellness-service/wellness/dailyHeartRate`;
+  }
+  WORKOUT(id) {
+    if (id) {
+      return `${this.GC_API}/workout-service/workout/${id}`;
+    }
+    return `${this.GC_API}/workout-service/workout`;
+  }
+  get WORKOUTS() {
+    return `${this.GC_API}/workout-service/workouts`;
+  }
+};
+
+// src/garmin/types/index.ts
+var UploadFileType = /* @__PURE__ */ ((UploadFileType2) => {
+  UploadFileType2["tcx"] = "tcx";
+  UploadFileType2["gpx"] = "gpx";
+  UploadFileType2["fit"] = "fit";
+  return UploadFileType2;
+})(UploadFileType || {});
+var GearStatus = /* @__PURE__ */ ((GearStatus2) => {
+  GearStatus2["ACTIVE"] = "active";
+  GearStatus2["RETIRED"] = "retired";
+  return GearStatus2;
+})(GearStatus || {});
+
+// src/garmin/workouts/templates/RunningTemplate.ts
+function RunningTemplate_default() {
+  return {
+    description: void 0,
+    workoutId: void 0,
+    sportType: {
+      sportTypeId: 1,
+      sportTypeKey: "running" /* running */
+    },
+    workoutName: "",
+    workoutSegments: [
+      {
+        segmentOrder: 1,
+        sportType: {
+          sportTypeId: 1,
+          sportTypeKey: "running" /* running */
+        },
+        workoutSteps: [
+          {
+            type: "ExecutableStepDTO" /* executableStepDTO */,
+            stepId: null,
+            stepOrder: 1,
+            childStepId: null,
+            description: null,
+            stepType: {
+              stepTypeId: 3,
+              stepTypeKey: "interval" /* interval */
+            },
+            endCondition: {
+              conditionTypeKey: "distance" /* distance */,
+              conditionTypeId: 3
+            },
+            preferredEndConditionUnit: {
+              unitKey: "kilometer" /* kilometer */
+            },
+            endConditionValue: null,
+            endConditionCompare: null,
+            endConditionZone: null,
+            targetType: {
+              workoutTargetTypeId: 1,
+              workoutTargetTypeKey: "no.target" /* noTarget */
+            },
+            targetValueOne: null,
+            targetValueTwo: null,
+            zoneNumber: null
+          }
+        ]
+      }
+    ]
+  };
+}
+__name(RunningTemplate_default, "default");
+
+// src/garmin/workouts/Running.ts
+var Running = class {
+  static {
+    __name(this, "Running");
+  }
+  constructor() {
+    this.data = RunningTemplate_default();
+  }
+  get name() {
+    return this.data.workoutName;
+  }
+  set name(name) {
+    this.data.workoutName = `${name}`;
+  }
+  get distance() {
+    return this.data.workoutSegments[0].workoutSteps[0].endConditionValue || 0;
+  }
+  set distance(meters) {
+    this.data.workoutSegments[0].workoutSteps[0].endConditionValue = Math.round(meters);
+  }
+  get workoutId() {
+    return this.data.workoutId;
+  }
+  set workoutId(workoutId) {
+    this.data.workoutId = workoutId;
+  }
+  get description() {
+    return this.data.description;
+  }
+  set description(description) {
+    this.data.description = description;
+  }
+  isValid() {
+    return !!(this.name && this.distance);
+  }
+  toJson() {
+    return this.data;
+  }
+  toString() {
+    return `${this.name}, ${(this.distance / 1e3).toFixed(2)}km`;
+  }
+};
+
+// src/garmin/common/DateUtils.ts
+function toDateString(date) {
+  const offset = date.getTimezoneOffset();
+  const offsetDate = new Date(date.getTime() - offset * 60 * 1e3);
+  const [dateString] = offsetDate.toISOString().split("T");
+  return dateString;
+}
+__name(toDateString, "toDateString");
+function calculateTimeDifference(sleepStartTimestampGMT, sleepEndTimestampGMT) {
+  const timeDifferenceInSeconds = (sleepEndTimestampGMT - sleepStartTimestampGMT) / 1e3;
+  const hours = Math.floor(timeDifferenceInSeconds / 3600);
+  const minutes = Math.floor(timeDifferenceInSeconds % 3600 / 60);
+  return {
+    hours,
+    minutes
+  };
+}
+__name(calculateTimeDifference, "calculateTimeDifference");
+function getLocalTimestamp(date, timezone) {
+  const localTimestampISO = date.toISOString().substring(0, 23);
+  const localTimestamp = new Date(localTimestampISO).toLocaleString("en-US", {
+    timeZone: timezone,
+    hour12: false
+  });
+  const formattedLocalTimestamp = new Date(localTimestamp).toISOString().substring(0, 23);
+  return formattedLocalTimestamp;
+}
+__name(getLocalTimestamp, "getLocalTimestamp");
+
+// src/garmin/common/WeightUtils.ts
+function gramsToPounds(weightInGrams) {
+  const gramsPerPound = 453.592;
+  return weightInGrams / gramsPerPound;
+}
+__name(gramsToPounds, "gramsToPounds");
+
+// src/garmin/common/HydrationUtils.ts
+function convertMLToOunces(valueInML) {
+  const conversionFactor = 0.033814;
+  const valueInOunces = valueInML * conversionFactor;
+  return valueInOunces;
+}
+__name(convertMLToOunces, "convertMLToOunces");
+function convertOuncesToML(ounces) {
+  const ouncesToMillilitersConversionFactor = 29.5735;
+  const milliliters = ounces * ouncesToMillilitersConversionFactor;
+  return milliliters;
+}
+__name(convertOuncesToML, "convertOuncesToML");
+
+// src/garmin/GarminConnect.ts
+var config = void 0;
+try {
+  config = import_app_root_path.default.require("/garmin.config.json");
+} catch (e) {
+}
+var GarminConnect = class {
+  static {
+    __name(this, "GarminConnect");
+  }
+  // private oauth1: OAuth;
+  constructor(credentials = config, domain = "garmin.com") {
+    if (!credentials) {
+      throw new Error("Missing credentials");
+    }
+    this.credentials = credentials;
+    this.url = new UrlClass(domain);
+    this.client = new HttpClient(this.url);
+    this._userHash = void 0;
+    this.listeners = {};
+  }
+  async login(username, password) {
+    if (username && password) {
+      this.credentials.username = username;
+      this.credentials.password = password;
+    }
+    await this.client.login(this.credentials.username, this.credentials.password);
+    return this;
+  }
+  exportTokenToFile(dirPath) {
+    if (!checkIsDirectory(dirPath)) {
+      createDirectory(dirPath);
+    }
+    if (this.client.oauth1Token) {
+      writeToFile(path.join(dirPath, "oauth1_token.json"), JSON.stringify(this.client.oauth1Token));
+    }
+    if (this.client.oauth2Token) {
+      writeToFile(path.join(dirPath, "oauth2_token.json"), JSON.stringify(this.client.oauth2Token));
+    }
+  }
+  loadTokenByFile(dirPath) {
+    if (!checkIsDirectory(dirPath)) {
+      throw new Error(`loadTokenByFile: Directory not found: ${dirPath}`);
+    }
+    const oauth1Data = fs.readFileSync(path.join(dirPath, "oauth1_token.json"));
+    this.client.oauth1Token = JSON.parse(oauth1Data);
+    const oauth2Data = fs.readFileSync(path.join(dirPath, "oauth2_token.json"));
+    this.client.oauth2Token = JSON.parse(oauth2Data);
+  }
+  exportToken() {
+    if (!this.client.oauth1Token || !this.client.oauth2Token) {
+      throw new Error("exportToken: Token not found");
+    }
+    return {
+      oauth1: this.client.oauth1Token,
+      oauth2: this.client.oauth2Token
+    };
+  }
+  // from db or localstorage etc
+  loadToken(oauth1, oauth2) {
+    this.client.oauth1Token = oauth1;
+    this.client.oauth2Token = oauth2;
+  }
+  getUserSettings() {
+    return this.client.get(this.url.USER_SETTINGS);
+  }
+  getUserProfile() {
+    return this.client.get(this.url.USER_PROFILE);
+  }
+  getActivities(start, limit, activityType, subActivityType) {
+    return this.client.get(this.url.ACTIVITIES, {
+      params: { start, limit, activityType, subActivityType }
+    });
+  }
+  getActivity(activity) {
+    if (!activity.activityId) throw new Error("Missing activityId");
+    return this.client.get(this.url.ACTIVITY + activity.activityId);
+  }
+  countActivities() {
+    return this.client.get(this.url.STAT_ACTIVITIES, {
+      params: {
+        aggregation: "lifetime",
+        startDate: "1970-01-01",
+        endDate: import_luxon2.DateTime.now().toFormat("yyyy-MM-dd"),
+        metric: "duration"
+      }
+    });
+  }
+  createGear(payload) {
+    return this.client.post(this.url.CREATE_GEAR, {
+      createDate: payload.createDate.toISOString(),
+      customMakeModel: payload.customMakeModel,
+      dateBegin: payload.dateBegin.toISOString(),
+      displayName: payload.displayName,
+      gearMakeName: payload.gearMakeName,
+      gearModelName: payload.gearModelName,
+      gearStatusName: "active",
+      maximumMeters: payload.maximumMeters
+    });
+  }
+  getGears(userProfilePk) {
+    return this.client.get(this.url.ACTIVITY_GEAR, {
+      params: {
+        userProfilePk
+      }
+    });
+  }
+  getActivityGear(activityId) {
+    return this.client.get(this.url.ACTIVITY_GEAR, {
+      params: {
+        activityId
+      }
+    });
+  }
+  linkActivityGear(gearUuid, activityId) {
+    return this.client.put(this.url.ACTIVITY_GEAR_LINK(gearUuid, activityId), {});
+  }
+  unlinkActivityGear(gearUuid, activityId) {
+    return this.client.put(this.url.ACTIVITY_GEAR_UNLINK(gearUuid, activityId), {});
+  }
+  async changeGearStatus(userProfileId, gearUuid, data) {
+    const gears = await this.getGears(userProfileId);
+    const gear = gears.find((g) => g.uuid === gearUuid);
+    if (!gear) {
+      throw new Error(`changeGearStatus: Gear with uuid ${gearUuid} not found`);
+    }
+    if (gear.gearStatusName === data.status) {
+      throw new Error(`changeGearStatus: Gear already has status ${data.status}`);
+    }
+    return this.client.put(this.url.GEAR_DATA(gearUuid), {
+      ...gear,
+      gearStatusName: data.status,
+      ...data.status === "retired" /* RETIRED */ ? { dateEnd: data.dateEnd.toISOString() } : {
+        dateEnd: null
+      }
+    });
+  }
+  async downloadOriginalActivityData(activity, dir, type = "zip") {
+    if (!activity.activityId) throw new Error("Missing activityId");
+    if (!checkIsDirectory(dir)) {
+      createDirectory(dir);
+    }
+    let fileBuffer;
+    if (type === "tcx") {
+      fileBuffer = await this.client.get(this.url.DOWNLOAD_TCX + activity.activityId);
+    } else if (type === "gpx") {
+      fileBuffer = await this.client.get(this.url.DOWNLOAD_GPX + activity.activityId);
+    } else if (type === "kml") {
+      fileBuffer = await this.client.get(this.url.DOWNLOAD_KML + activity.activityId);
+    } else if (type === "zip") {
+      fileBuffer = await this.client.get(this.url.DOWNLOAD_ZIP + activity.activityId, {
+        responseType: "arraybuffer"
+      });
+    } else {
+      throw new Error(`downloadOriginalActivityData - Invalid type: ${type}`);
+    }
+    writeToFile(path.join(dir, `${activity.activityId}.${type}`), fileBuffer);
+  }
+  uploadActivity(file, format = "fit") {
+    const detectedFormat = (format || path.extname(file))?.toLowerCase();
+    if (!import_lodash2.default.includes(UploadFileType, detectedFormat)) {
+      throw new Error(`uploadActivity - Invalid format: ${format}`);
+    }
+    const fileBuffer = fs.createReadStream(file);
+    const form = new import_form_data2.default();
+    form.append("userfile", fileBuffer);
+    return this.client.post(this.url.UPLOAD(format), form, {
+      headers: {
+        "Content-Type": form.getHeaders()["content-type"]
+      }
+    });
+  }
+  getUploadActivityDetails(uploadCreationDate, activityId) {
+    const creationDate = new Date(uploadCreationDate);
+    return this.client.get(this.url.UPLOAD_ACTIVITY_STATUS(creationDate.getTime(), activityId));
+  }
+  deleteActivity(activity) {
+    if (!activity.activityId) throw new Error("Missing activityId");
+    return this.client.delete(this.url.ACTIVITY + activity.activityId);
+  }
+  getWorkouts(start, limit) {
+    return this.client.get(this.url.WORKOUTS, {
+      params: {
+        start,
+        limit
+      }
+    });
+  }
+  getWorkoutDetail(workout) {
+    if (!workout.workoutId) throw new Error("Missing workoutId");
+    return this.client.get(this.url.WORKOUT(workout.workoutId));
+  }
+  addWorkout(workout) {
+    if (!workout) throw new Error("Missing workout");
+    if (workout instanceof Running) {
+      if (workout.isValid()) {
+        const data = { ...workout.toJson() };
+        if (!data.description) {
+          data.description = "Added by garmin-connect for Node.js";
+        }
+        return this.client.post(this.url.WORKOUT(), data);
+      }
+    }
+    const newWorkout = import_lodash2.default.omit(workout, ["workoutId", "ownerId", "updatedDate", "createdDate", "author"]);
+    if (!newWorkout.description) {
+      newWorkout.description = "Added by garmin-connect for Node.js";
+    }
+    return this.client.post(this.url.WORKOUT(), newWorkout);
+  }
+  addRunningWorkout(name, meters, description) {
+    const running = new Running();
+    running.name = name;
+    running.distance = meters;
+    running.description = description;
+    return this.addWorkout(running);
+  }
+  deleteWorkout(workout) {
+    if (!workout.workoutId) throw new Error("Missing workout");
+    return this.client.delete(this.url.WORKOUT(workout.workoutId));
+  }
+  addActivity(activity) {
+    return this.client.post(this.url.ACTIVITY, activity);
+  }
+  async getSteps(date = /* @__PURE__ */ new Date()) {
+    const dateString = toDateString(date);
+    const days = await this.client.get(`${this.url.DAILY_STEPS}${dateString}/${dateString}`);
+    const dayStats = days.find(({ calendarDate }) => calendarDate === dateString);
+    if (!dayStats) {
+      throw new Error("Can't find daily steps for this date.");
+    }
+    return dayStats.totalSteps;
+  }
+  async getSleepData(date = /* @__PURE__ */ new Date()) {
+    try {
+      const dateString = toDateString(date);
+      const sleepData = await this.client.get(`${this.url.DAILY_SLEEP}`, { params: { date: dateString } });
+      if (!sleepData) {
+        throw new Error("Invalid or empty sleep data response.");
+      }
+      return sleepData;
+    } catch (error) {
+      throw new Error(`Error in getSleepData: ${error.message}`);
+    }
+  }
+  async getSleepDuration(date = /* @__PURE__ */ new Date()) {
+    try {
+      const sleepData = await this.getSleepData(date);
+      if (!sleepData || !sleepData.dailySleepDTO || sleepData.dailySleepDTO.sleepStartTimestampGMT === void 0 || sleepData.dailySleepDTO.sleepEndTimestampGMT === void 0) {
+        throw new Error("Invalid or missing sleep data for the specified date.");
+      }
+      const sleepStartTimestampGMT = sleepData.dailySleepDTO.sleepStartTimestampGMT;
+      const sleepEndTimestampGMT = sleepData.dailySleepDTO.sleepEndTimestampGMT;
+      const { hours, minutes } = calculateTimeDifference(sleepStartTimestampGMT, sleepEndTimestampGMT);
+      return {
+        hours,
+        minutes
+      };
+    } catch (error) {
+      throw new Error(`Error in getSleepDuration: ${error.message}`);
+    }
+  }
+  async getDailyWeightData(date = /* @__PURE__ */ new Date()) {
+    try {
+      const dateString = toDateString(date);
+      const weightData = await this.client.get(`${this.url.DAILY_WEIGHT}/${dateString}`);
+      if (!weightData) {
+        throw new Error("Invalid or empty weight data response.");
+      }
+      return weightData;
+    } catch (error) {
+      throw new Error(`Error in getDailyWeightData: ${error.message}`);
+    }
+  }
+  async getDailyWeightInPounds(date = /* @__PURE__ */ new Date()) {
+    const weightData = await this.getDailyWeightData(date);
+    if (weightData.totalAverage && typeof weightData.totalAverage.weight === "number") {
+      return gramsToPounds(weightData.totalAverage.weight);
+    }
+    throw new Error("Can't find valid daily weight for this date.");
+  }
+  async getDailyHydration(date = /* @__PURE__ */ new Date()) {
+    try {
+      const dateString = toDateString(date);
+      const hydrationData = await this.client.get(`${this.url.DAILY_HYDRATION}/${dateString}`);
+      if (!hydrationData || !hydrationData.valueInML) {
+        throw new Error("Invalid or empty hydration data response.");
+      }
+      return convertMLToOunces(hydrationData.valueInML);
+    } catch (error) {
+      throw new Error(`Error in getDailyHydration: ${error.message}`);
+    }
+  }
+  async updateWeight(date, lbs, timezone) {
+    try {
+      const weightData = await this.client.post(`${this.url.UPDATE_WEIGHT}`, {
+        dateTimestamp: getLocalTimestamp(date, timezone),
+        gmtTimestamp: date.toISOString().substring(0, 23),
+        unitKey: "lbs",
+        value: lbs
+      });
+      return weightData;
+    } catch (error) {
+      throw new Error(`Error in updateWeight: ${error.message}`);
+    }
+  }
+  async updateHydrationLogOunces(date, valueInOz) {
+    try {
+      const dateString = toDateString(date);
+      const hydrationData = await this.client.put(`${this.url.HYDRATION_LOG}`, {
+        calendarDate: dateString,
+        valueInML: convertOuncesToML(valueInOz),
+        userProfileId: (await this.getUserProfile()).profileId,
+        timestampLocal: date.toISOString().substring(0, 23)
+      });
+      return hydrationData;
+    } catch (error) {
+      throw new Error(`Error in updateHydrationLogOunces: ${error.message}`);
+    }
+  }
+  async getGolfSummary() {
+    try {
+      const golfSummary = await this.client.get(`${this.url.GOLF_SCORECARD_SUMMARY}`);
+      if (!golfSummary) {
+        throw new Error("Invalid or empty golf summary data response.");
+      }
+      return golfSummary;
+    } catch (error) {
+      throw new Error(`Error in getGolfSummary: ${error.message}`);
+    }
+  }
+  async getGolfScorecard(scorecardId) {
+    try {
+      const golfScorecard = await this.client.get(`${this.url.GOLF_SCORECARD_DETAIL}`, {
+        params: { "scorecard-ids": scorecardId }
+      });
+      if (!golfScorecard) {
+        throw new Error("Invalid or empty golf scorecard data response.");
+      }
+      return golfScorecard;
+    } catch (error) {
+      throw new Error(`Error in getGolfScorecard: ${error.message}`);
+    }
+  }
+  async getHeartRate(date = /* @__PURE__ */ new Date()) {
+    try {
+      const dateString = toDateString(date);
+      const heartRate = await this.client.get(`${this.url.DAILY_HEART_RATE}`, {
+        params: { date: dateString }
+      });
+      return heartRate;
+    } catch (error) {
+      throw new Error(`Error in getHeartRate: ${error.message}`);
+    }
+  }
+  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
+  get(url, data) {
+    return this.client.get(url, data);
+  }
+  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
+  post(url, data) {
+    return this.client.post(url, data, {});
+  }
+  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
+  put(url, data) {
+    return this.client.put(url, data, {});
+  }
+};
+
+// src/garmin/types/activity.ts
+var ActivityType = /* @__PURE__ */ ((ActivityType2) => {
+  ActivityType2["Cycling"] = "cycling";
+  ActivityType2["FitnessEquipment"] = "fitness_equipment";
+  ActivityType2["Walking"] = "walking";
+  ActivityType2["Hiking"] = "hiking";
+  ActivityType2["Other"] = "other";
+  ActivityType2["WaterSport"] = "water_sports";
+  ActivityType2["Running"] = "running";
+  return ActivityType2;
+})(ActivityType || {});
+var ActivitySubType = /* @__PURE__ */ ((ActivitySubType2) => {
+  ActivitySubType2["IndoorCardio"] = "indoor_cardio";
+  ActivitySubType2["StrengthTraining"] = "strength_training";
+  ActivitySubType2["HIIT"] = "hiit";
+  ActivitySubType2["Yoga"] = "yoga";
+  ActivitySubType2["IndoorCycling"] = "indoor_cycling";
+  ActivitySubType2["Breathwork"] = "breathwork";
+  ActivitySubType2["Surfing"] = "surfing";
+  ActivitySubType2["StreetRunning"] = "street_running";
+  ActivitySubType2["TrailRunning"] = "trail_running";
+  ActivitySubType2["IndoorRunning"] = "indoor_running";
+  return ActivitySubType2;
+})(ActivitySubType || {});
+// Annotate the CommonJS export names for ESM import in node:
+0 && (module.exports = {
+  ActivitySubType,
+  ActivityType,
+  GarminConnect,
+  GearStatus
+});
diff --git a/dist/index.d.cts b/dist/index.d.cts
new file mode 100644
index 0000000000000000000000000000000000000000..1390408a1a2e1262ea4bfd58bb806b307169a8a6
--- /dev/null
+++ b/dist/index.d.cts
@@ -0,0 +1,1320 @@
+import { AxiosInstance, AxiosRequestConfig, RawAxiosRequestHeaders, AxiosResponse } from 'axios';
+import OAuth$1 from 'oauth-1.0a';
+
+type GCUserProfileId = number;
+type GCUserHash = string;
+type GCWorkoutId = string;
+type GCGearId = number;
+type GCGearUuid = string;
+type GarminDomain = 'garmin.com' | 'garmin.cn';
+declare enum ExportFileType {
+    tcx = "tcx",
+    gpx = "gpx",
+    kml = "kml",
+    zip = "zip"
+}
+declare enum UploadFileType {
+    tcx = "tcx",
+    gpx = "gpx",
+    fit = "fit"
+}
+type ExportFileTypeValue = keyof typeof ExportFileType;
+type UploadFileTypeTypeValue = keyof typeof UploadFileType;
+interface ISocialProfile {
+    id: number;
+    profileId: GCUserProfileId;
+    garminGUID: string;
+    displayName: GCUserHash;
+    fullName: string;
+    userName: string;
+    profileImageUuid: unknown;
+    profileImageUrlLarge: string;
+    profileImageUrlMedium: string;
+    profileImageUrlSmall: string;
+    location: string;
+    facebookUrl: unknown;
+    twitterUrl: unknown;
+    personalWebsite: unknown;
+    motivation: unknown;
+    bio: unknown;
+    primaryActivity: unknown;
+    favoriteActivityTypes: unknown[];
+    runningTrainingSpeed: number;
+    cyclingTrainingSpeed: number;
+    favoriteCyclingActivityTypes: unknown[];
+    cyclingClassification: unknown;
+    cyclingMaxAvgPower: number;
+    swimmingTrainingSpeed: number;
+    profileVisibility: string;
+    activityStartVisibility: string;
+    activityMapVisibility: string;
+    courseVisibility: string;
+    activityHeartRateVisibility: string;
+    activityPowerVisibility: string;
+    badgeVisibility: string;
+    showAge: boolean;
+    showWeight: boolean;
+    showHeight: boolean;
+    showWeightClass: boolean;
+    showAgeRange: boolean;
+    showGender: boolean;
+    showActivityClass: boolean;
+    showVO2Max: boolean;
+    showPersonalRecords: boolean;
+    showLast12Months: boolean;
+    showLifetimeTotals: boolean;
+    showUpcomingEvents: boolean;
+    showRecentFavorites: boolean;
+    showRecentDevice: boolean;
+    showRecentGear: boolean;
+    showBadges: boolean;
+    otherActivity: null;
+    otherPrimaryActivity: null;
+    otherMotivation: null;
+    userRoles: string[];
+    nameApproved: boolean;
+    userProfileFullName: string;
+    makeGolfScorecardsPrivate: boolean;
+    allowGolfLiveScoring: boolean;
+    allowGolfScoringByConnections: boolean;
+    userLevel: number;
+    userPoint: number;
+    levelUpdateDate: string;
+    levelIsViewed: boolean;
+    levelPointThreshold: number;
+    userPointOffset: number;
+    userPro: boolean;
+}
+declare enum GearStatus {
+    ACTIVE = "active",
+    RETIRED = "retired"
+}
+interface Gear {
+    gearPk: GCGearId;
+    uuid: GCGearUuid;
+    userProfilePk: GCUserProfileId;
+    gearMakeName: string;
+    gearModelName: string;
+    gearTypeName: 'Shoes' | 'Bike' | 'Other' | string;
+    gearStatusName: GearStatus;
+    displayName: string | null;
+    customMakeModel: string;
+    imageNameLarge: string | null;
+    imageNameMedium: string | null;
+    imageNameSmall: string | null;
+    dateBegin: string;
+    dateEnd: string | null;
+    maximumMeters: number;
+    notified: boolean;
+    createDate: string;
+    updateDate: string;
+}
+interface IOauth1Consumer {
+    key: string;
+    secret: string;
+}
+interface IOauth1 {
+    token: IOauth1Token;
+    oauth: OAuth;
+}
+interface IGarminTokens {
+    oauth1: IOauth1Token;
+    oauth2: IOauth2Token;
+}
+interface IOauth1Token {
+    oauth_token: string;
+    oauth_token_secret: string;
+}
+interface IOauth2Token {
+    scope: string;
+    jti: string;
+    access_token: string;
+    token_type: string;
+    refresh_token: string;
+    expires_in: number;
+    refresh_token_expires_in: number;
+    expires_at: number;
+    refresh_token_expires_at: number;
+    last_update_date: string;
+    expires_date: string;
+}
+interface IUserSettings {
+    id: number;
+    userData: IUserData;
+    userSleep: {
+        sleepTime: number;
+        defaultSleepTime: boolean;
+        wakeTime: number;
+        defaultWakeTime: boolean;
+    };
+    connectDate: unknown;
+    sourceType: unknown;
+    userSleepWindows: IUserSleepWindows[];
+}
+interface IUserData {
+    gender: unknown;
+    weight: unknown;
+    height: unknown;
+    timeFormat: string;
+    birthDate: unknown;
+    measurementSystem: string;
+    activityLevel: unknown;
+    handedness: string;
+    powerFormat: {
+        formatId: number;
+        formatKey: string;
+        minFraction: number;
+        maxFraction: number;
+        groupingUsed: boolean;
+        displayFormat: unknown;
+    };
+    heartRateFormat: {
+        formatId: number;
+        formatKey: string;
+        minFraction: number;
+        maxFraction: number;
+        groupingUsed: boolean;
+        displayFormat: unknown;
+    };
+    firstDayOfWeek: {
+        dayId: number;
+        dayName: string;
+        sortOrder: number;
+        isPossibleFirstDay: boolean;
+    };
+    vo2MaxRunning: unknown;
+    vo2MaxCycling: unknown;
+    lactateThresholdSpeed: unknown;
+    lactateThresholdHeartRate: unknown;
+    diveNumber: unknown;
+    intensityMinutesCalcMethod: string;
+    moderateIntensityMinutesHrZone: number;
+    vigorousIntensityMinutesHrZone: number;
+    hydrationMeasurementUnit: string;
+    hydrationContainers: unknown[];
+    hydrationAutoGoalEnabled: boolean;
+    firstbeatMaxStressScore: unknown;
+    firstbeatCyclingLtTimestamp: unknown;
+    firstbeatRunningLtTimestamp: unknown;
+    thresholdHeartRateAutoDetected: unknown;
+    ftpAutoDetected: unknown;
+    trainingStatusPausedDate: unknown;
+    weatherLocation: {
+        useFixedLocation: unknown;
+        latitude: unknown;
+        longitude: unknown;
+        locationName: unknown;
+        isoCountryCode: unknown;
+        postalCode: unknown;
+    };
+    golfDistanceUnit: string;
+    golfElevationUnit: unknown;
+    golfSpeedUnit: unknown;
+    externalBottomTime: unknown;
+}
+interface IUserSleepWindows {
+    sleepWindowFrequency: string;
+    startSleepTimeSecondsFromMidnight: number;
+    endSleepTimeSecondsFromMidnight: number;
+}
+interface ICountActivities {
+    countOfActivities: number;
+    date: string;
+    stats: {
+        all: Record<string, any>;
+    };
+}
+interface IWorkout {
+    workoutId?: number;
+    ownerId?: number;
+    workoutName: string;
+    description?: string;
+    updateDate: Date;
+    createdDate: Date;
+    sportType: ISportType$1;
+    trainingPlanId: null;
+    author: IAuthor;
+    estimatedDurationInSecs: number;
+    estimatedDistanceInMeters: null;
+    estimateType: null;
+    estimatedDistanceUnit: IUnit;
+    poolLength: number;
+    poolLengthUnit: IUnit;
+    workoutProvider: string;
+    workoutSourceId: string;
+    consumer: null;
+    atpPlanId: null;
+    workoutNameI18nKey: null;
+    descriptionI18nKey: null;
+    shared: boolean;
+    estimated: boolean;
+}
+interface IWorkoutDetail extends IWorkout {
+    workoutSegments: IWorkoutSegment$1[];
+}
+interface IAuthor {
+    userProfilePk: null;
+    displayName: null;
+    fullName: null;
+    profileImgNameLarge: null;
+    profileImgNameMedium: null;
+    profileImgNameSmall: null;
+    userPro: boolean;
+    vivokidUser: boolean;
+}
+interface IUnit {
+    unitId: null;
+    unitKey: null;
+    factor: null;
+}
+interface ISportType$1 {
+    sportTypeId: number;
+    sportTypeKey: string;
+    displayOrder?: number;
+}
+interface IWorkoutSegment$1 {
+    segmentOrder: number;
+    sportType: ISportType$1;
+    workoutSteps: IWorkoutStep$1[];
+}
+interface IWorkoutStep$1 {
+    type: string;
+    stepId: number;
+    stepOrder: number;
+    stepType: IStepType$1;
+    childStepId: null;
+    description: null;
+    endCondition: IEndCondition$1;
+    endConditionValue: number | null;
+    preferredEndConditionUnit: IUnit | null;
+    endConditionCompare: null;
+    targetType: ITargetType$1;
+    targetValueOne: null;
+    targetValueTwo: null;
+    targetValueUnit: null;
+    zoneNumber: null;
+    secondaryTargetType: null;
+    secondaryTargetValueOne: null;
+    secondaryTargetValueTwo: null;
+    secondaryTargetValueUnit: null;
+    secondaryZoneNumber: null;
+    endConditionZone: null;
+    strokeType: IStrokeType;
+    equipmentType: IEquipmentType;
+    category: null;
+    exerciseName: null;
+    workoutProvider: null;
+    providerExerciseSourceId: null;
+    weightValue: null;
+    weightUnit: null;
+}
+interface IEndCondition$1 {
+    conditionTypeId: number;
+    conditionTypeKey: string;
+    displayOrder: number;
+    displayable: boolean;
+}
+interface IEquipmentType {
+    equipmentTypeId: number;
+    equipmentTypeKey: null;
+    displayOrder: number;
+}
+interface IStepType$1 {
+    stepTypeId: number;
+    stepTypeKey: string;
+    displayOrder: number;
+}
+interface IStrokeType {
+    strokeTypeId: number;
+    strokeTypeKey: null;
+    displayOrder: number;
+}
+interface ITargetType$1 {
+    workoutTargetTypeId: number;
+    workoutTargetTypeKey: string;
+    displayOrder: number;
+}
+
+type GCActivityId = number;
+declare enum ActivityType {
+    Cycling = "cycling",
+    FitnessEquipment = "fitness_equipment",
+    Walking = "walking",
+    Hiking = "hiking",
+    Other = "other",
+    WaterSport = "water_sports",
+    Running = "running"
+}
+declare enum ActivitySubType {
+    IndoorCardio = "indoor_cardio",// Maps to FitnessEquipment
+    StrengthTraining = "strength_training",// Maps to FitnessEquipment
+    HIIT = "hiit",// Maps to FitnessEquipment
+    Yoga = "yoga",// Maps to FitnessEquipment
+    IndoorCycling = "indoor_cycling",// Maps to Cycling
+    Breathwork = "breathwork",// Maps to Other
+    Surfing = "surfing",// Maps to WaterSport
+    StreetRunning = "street_running",// Maps to Running
+    TrailRunning = "trail_running",// Maps to Running
+    IndoorRunning = "indoor_running"
+}
+interface IActivityUploadDetails {
+    detailedImportResult: {
+        uploadId: number;
+        uploadUuid: {
+            uuid: string;
+        };
+        owner: GCUserProfileId;
+        fileSize: number;
+        processingTime: number;
+        creationDate: string;
+        ipAddress: string | null;
+        fileName: string;
+        report: string | null;
+        successes: {
+            internalId: number;
+            externalId: string | null;
+            messages: {
+                code: number;
+                content: string;
+            }[] | null;
+        }[];
+        failures: {
+            internalId: number;
+            externalId: string | null;
+            messages: {
+                code: number;
+                content: string;
+            }[] | null;
+        }[];
+    };
+}
+interface IActivity {
+    activityId: GCActivityId;
+    activityName: string;
+    description: unknown;
+    startTimeLocal: string;
+    startTimeGMT: string;
+    activityType: {
+        typeId: number;
+        typeKey: string;
+        parentTypeId: number;
+        isHidden: boolean;
+        sortOrder: unknown;
+        trimmable: boolean;
+        restricted: boolean;
+    };
+    eventType: {
+        typeId: number;
+        typeKey: string;
+        sortOrder: number;
+    };
+    comments: unknown;
+    parentId: unknown;
+    distance: number;
+    duration: number;
+    elapsedDuration: number;
+    movingDuration: number;
+    elevationGain: number;
+    elevationLoss: number;
+    averageSpeed: number;
+    maxSpeed: number;
+    startLatitude: number;
+    startLongitude: number;
+    hasPolyline: boolean;
+    ownerId: number;
+    ownerDisplayName: string;
+    ownerFullName: string;
+    ownerProfileImageUrlSmall: string;
+    ownerProfileImageUrlMedium: string;
+    ownerProfileImageUrlLarge: string;
+    calories: number;
+    averageHR: number;
+    maxHR: number;
+    averageRunningCadenceInStepsPerMinute: number;
+    maxRunningCadenceInStepsPerMinute: number;
+    averageBikingCadenceInRevPerMinute: unknown;
+    maxBikingCadenceInRevPerMinute: unknown;
+    averageSwimCadenceInStrokesPerMinute: unknown;
+    maxSwimCadenceInStrokesPerMinute: unknown;
+    averageSwolf: unknown;
+    activeLengths: unknown;
+    steps: number;
+    conversationUuid: unknown;
+    conversationPk: unknown;
+    numberOfActivityLikes: unknown;
+    numberOfActivityComments: unknown;
+    likedByUser: unknown;
+    commentedByUser: unknown;
+    activityLikeDisplayNames: unknown;
+    activityLikeFullNames: unknown;
+    activityLikeProfileImageUrls: unknown;
+    requestorRelationship: unknown;
+    userRoles: string[];
+    privacy: {
+        typeId: number;
+        typeKey: string;
+    };
+    userPro: boolean;
+    courseId: unknown;
+    poolLength: unknown;
+    unitOfPoolLength: unknown;
+    hasVideo: boolean;
+    videoUrl: unknown;
+    timeZoneId: number;
+    beginTimestamp: number;
+    sportTypeId: number;
+    avgPower: unknown;
+    maxPower: unknown;
+    aerobicTrainingEffect: unknown;
+    anaerobicTrainingEffect: unknown;
+    strokes: unknown;
+    normPower: unknown;
+    leftBalance: unknown;
+    rightBalance: unknown;
+    avgLeftBalance: unknown;
+    max20MinPower: unknown;
+    avgVerticalOscillation: unknown;
+    avgGroundContactTime: unknown;
+    avgStrideLength: number;
+    avgFractionalCadence: unknown;
+    maxFractionalCadence: unknown;
+    trainingStressScore: unknown;
+    intensityFactor: unknown;
+    vO2MaxValue: number;
+    avgVerticalRatio: unknown;
+    avgGroundContactBalance: unknown;
+    lactateThresholdBpm: unknown;
+    lactateThresholdSpeed: unknown;
+    maxFtp: unknown;
+    avgStrokeDistance: unknown;
+    avgStrokeCadence: unknown;
+    maxStrokeCadence: unknown;
+    workoutId: unknown;
+    avgStrokes: unknown;
+    minStrokes: unknown;
+    deviceId: number;
+    minTemperature: unknown;
+    maxTemperature: unknown;
+    minElevation: number;
+    maxElevation: number;
+    avgDoubleCadence: unknown;
+    maxDoubleCadence: number;
+    summarizedExerciseSets: unknown;
+    maxDepth: unknown;
+    avgDepth: unknown;
+    surfaceInterval: unknown;
+    startN2: unknown;
+    endN2: unknown;
+    startCns: unknown;
+    endCns: unknown;
+    summarizedDiveInfo: {
+        weight: unknown;
+        weightUnit: unknown;
+        visibility: unknown;
+        visibilityUnit: unknown;
+        surfaceCondition: unknown;
+        current: unknown;
+        waterType: unknown;
+        waterDensity: unknown;
+        summarizedDiveGases: [];
+        totalSurfaceTime: unknown;
+    };
+    activityLikeAuthors: unknown;
+    avgVerticalSpeed: unknown;
+    maxVerticalSpeed: number;
+    floorsClimbed: unknown;
+    floorsDescended: unknown;
+    manufacturer: string;
+    diveNumber: unknown;
+    locationName: string;
+    bottomTime: unknown;
+    lapCount: number;
+    endLatitude: number;
+    endLongitude: number;
+    minAirSpeed: unknown;
+    maxAirSpeed: unknown;
+    avgAirSpeed: unknown;
+    avgWindYawAngle: unknown;
+    minCda: unknown;
+    maxCda: unknown;
+    avgCda: unknown;
+    avgWattsPerCda: unknown;
+    flow: unknown;
+    grit: unknown;
+    jumpCount: unknown;
+    caloriesEstimated: unknown;
+    caloriesConsumed: unknown;
+    waterEstimated: unknown;
+    waterConsumed: unknown;
+    maxAvgPower_1: unknown;
+    maxAvgPower_2: unknown;
+    maxAvgPower_5: unknown;
+    maxAvgPower_10: unknown;
+    maxAvgPower_20: unknown;
+    maxAvgPower_30: unknown;
+    maxAvgPower_60: unknown;
+    maxAvgPower_120: unknown;
+    maxAvgPower_300: unknown;
+    maxAvgPower_600: unknown;
+    maxAvgPower_1200: unknown;
+    maxAvgPower_1800: unknown;
+    maxAvgPower_3600: unknown;
+    maxAvgPower_7200: unknown;
+    maxAvgPower_18000: unknown;
+    excludeFromPowerCurveReports: unknown;
+    totalSets: unknown;
+    activeSets: unknown;
+    totalReps: unknown;
+    minRespirationRate: unknown;
+    maxRespirationRate: unknown;
+    avgRespirationRate: unknown;
+    trainingEffectLabel: unknown;
+    activityTrainingLoad: unknown;
+    avgFlow: unknown;
+    avgGrit: unknown;
+    minActivityLapDuration: number;
+    avgStress: unknown;
+    startStress: unknown;
+    endStress: unknown;
+    differenceStress: unknown;
+    maxStress: unknown;
+    aerobicTrainingEffectMessage: unknown;
+    anaerobicTrainingEffectMessage: unknown;
+    splitSummaries: [];
+    hasSplits: boolean;
+    maxBottomTime: unknown;
+    hasSeedFirstbeatProfile: unknown;
+    calendarEventId: unknown;
+    calendarEventUuid: unknown;
+    avgGradeAdjustedSpeed: unknown;
+    avgWheelchairCadence: unknown;
+    maxWheelchairCadence: unknown;
+    purposeful: boolean;
+    manualActivity: boolean;
+    autoCalcCalories: boolean;
+    elevationCorrected: boolean;
+    atpActivity: boolean;
+    favorite: boolean;
+    decoDive: unknown;
+    pr: boolean;
+    parent: boolean;
+}
+interface IActivityDetails {
+    activityId: number;
+    activityUUID: {
+        uuid: string;
+    };
+    activityName: string;
+    userProfileId: number;
+    isMultiSportParent: boolean;
+    activityTypeDTO: {
+        typeId: number;
+        typeKey: string;
+        parentTypeId: number;
+        isHidden: boolean;
+        restricted: boolean;
+        trimmable: boolean;
+    };
+    eventTypeDTO: {
+        typeId: number;
+        typeKey: string;
+        sortOrder: number;
+    };
+    accessControlRuleDTO: {
+        typeId: number;
+        typeKey: string;
+    };
+    timeZoneUnitDTO: {
+        unitId: number;
+        unitKey: string;
+        factor: number;
+        timeZone: string;
+    };
+    metadataDTO: {
+        isOriginal: boolean;
+        deviceApplicationInstallationId: number;
+        agentApplicationInstallationId?: null;
+        agentString?: null;
+        fileFormat: {
+            formatId: number;
+            formatKey: string;
+        };
+        associatedCourseId?: null;
+        lastUpdateDate: string;
+        uploadedDate: string;
+        videoUrl?: null;
+        hasPolyline: boolean;
+        hasChartData: boolean;
+        hasHrTimeInZones: boolean;
+        hasPowerTimeInZones: boolean;
+        userInfoDto: {
+            userProfilePk: number;
+            displayname: string;
+            fullname: string;
+            profileImageUrlLarge?: null;
+            profileImageUrlMedium: string;
+            profileImageUrlSmall: string;
+            userPro: boolean;
+        };
+        childIds?: null[] | null;
+        childActivityTypes?: null[] | null;
+        sensors?: {
+            manufacturer: string;
+            serialNumber: number;
+            sku: string;
+            fitProductNumber: number;
+            sourceType: string;
+            antplusDeviceType: string;
+            softwareVersion: number;
+            batteryStatus: string;
+        }[] | null;
+        activityImages?: {
+            imageId: string;
+            url: string;
+            smallUrl: string;
+            mediumUrl: string;
+            expirationTimestamp?: null;
+            latitude?: null;
+            longitude?: null;
+            photoDate?: null;
+        }[] | null;
+        manufacturer: string;
+        diveNumber?: null;
+        lapCount: number;
+        associatedWorkoutId: number;
+        isAtpActivity?: null;
+        deviceMetaDataDTO: {
+            deviceId: string;
+            deviceTypePk: number;
+            deviceVersionPk: number;
+        };
+        hasIntensityIntervals: boolean;
+        hasSplits: boolean;
+        eBikeMaxAssistModes?: null;
+        eBikeBatteryUsage?: null;
+        eBikeBatteryRemaining?: null;
+        eBikeAssistModeInfoDTOList?: null;
+        calendarEventInfo?: null;
+        personalRecord: boolean;
+        gcj02: boolean;
+        runPowerWindDataEnabled?: null;
+        autoCalcCalories: boolean;
+        favorite: boolean;
+        manualActivity: boolean;
+        trimmed: boolean;
+        elevationCorrected: boolean;
+    };
+    summaryDTO: {
+        startTimeLocal: string;
+        startTimeGMT: string;
+        startLatitude: number;
+        startLongitude: number;
+        distance: number;
+        duration: number;
+        movingDuration: number;
+        elapsedDuration: number;
+        elevationGain: number;
+        elevationLoss: number;
+        maxElevation: number;
+        minElevation: number;
+        averageSpeed: number;
+        averageMovingSpeed: number;
+        maxSpeed: number;
+        calories: number;
+        averageHR: number;
+        maxHR: number;
+        averageRunCadence: number;
+        maxRunCadence: number;
+        averageTemperature: number;
+        maxTemperature: number;
+        minTemperature: number;
+        groundContactTime: number;
+        groundContactBalanceLeft: number;
+        strideLength: number;
+        verticalOscillation: number;
+        trainingEffect: number;
+        anaerobicTrainingEffect: number;
+        aerobicTrainingEffectMessage: string;
+        anaerobicTrainingEffectMessage: string;
+        verticalRatio: number;
+        endLatitude: number;
+        endLongitude: number;
+        maxVerticalSpeed: number;
+        minActivityLapDuration: number;
+    };
+    locationName: string;
+    splitSummaries?: {
+        distance: number;
+        duration: number;
+        movingDuration: number;
+        elapsedDuration: number;
+        elevationGain: number;
+        elevationLoss: number;
+        averageSpeed: number;
+        averageMovingSpeed: number;
+        maxSpeed: number;
+        calories: number;
+        averageHR: number;
+        maxHR: number;
+        averageRunCadence: number;
+        maxRunCadence: number;
+        averageTemperature: number;
+        maxTemperature: number;
+        minTemperature: number;
+        groundContactTime: number;
+        groundContactBalanceLeft: number;
+        strideLength: number;
+        verticalOscillation: number;
+        verticalRatio: number;
+        totalExerciseReps: number;
+        splitType: string;
+        noOfSplits: number;
+        maxElevationGain: number;
+        averageElevationGain: number;
+        maxDistance: number;
+    }[] | null;
+}
+interface INewActivity {
+    accessControlRuleDTO: {
+        typeId: number;
+        typeKey: string;
+    };
+    activityName: string;
+    activityTypeDTO: {
+        typeKey: string;
+    };
+    description: string | null;
+    eventTypeDTO: {
+        typeKey: string;
+    };
+    metadataDTO: {
+        associatedCourseId: string | null;
+        autoCalcCalories: boolean;
+        videoUrl: string | null;
+    };
+    summaryDTO: {
+        averageHR: number | null;
+        averagePower: number | null;
+        averageRunCadence: number | null;
+        averageTemperature: number | null;
+        bmrCalories: number | null;
+        calories: number | null;
+        distance: number;
+        duration: number;
+        elapsedDuration: number | null;
+        elevationGain: number | null;
+        elevationLoss: number | null;
+        endLatitude: number | null;
+        endLongitude: number | null;
+        maxElevation: number | null;
+        minElevation: number | null;
+        maxHR: number | null;
+        maxRunCadence: number | null;
+        maxTemperature: number | null;
+        minTemperature: number | null;
+        movingDuration: number | null;
+        startTimeLocal: string;
+        startTimeGMT: string | null;
+        startLatitude: number | null;
+        startLongitude: number | null;
+    };
+    timeZoneUnitDTO: {
+        unitKey: string;
+    };
+}
+
+declare class UrlClass {
+    private domain;
+    GC_MODERN: string;
+    GARMIN_SSO_ORIGIN: string;
+    GC_API: string;
+    constructor(domain?: GarminDomain);
+    get GARMIN_SSO(): string;
+    get GARMIN_SSO_EMBED(): string;
+    get BASE_URL(): string;
+    get SIGNIN_URL(): string;
+    get LOGIN_URL(): string;
+    get OAUTH_URL(): string;
+    get USER_SETTINGS(): string;
+    get USER_PROFILE(): string;
+    get ACTIVITIES(): string;
+    get ACTIVITY(): string;
+    get STAT_ACTIVITIES(): string;
+    get CREATE_GEAR(): string;
+    get ACTIVITY_GEAR(): string;
+    GEAR_DATA(gearId: GCGearUuid): string;
+    ACTIVITY_GEAR_LINK(gearId: GCGearUuid, activityId: GCActivityId): string;
+    ACTIVITY_GEAR_UNLINK(gearId: GCGearUuid, activityId: GCActivityId): string;
+    get DOWNLOAD_ZIP(): string;
+    get DOWNLOAD_GPX(): string;
+    get DOWNLOAD_TCX(): string;
+    get DOWNLOAD_KML(): string;
+    UPLOAD(format: UploadFileTypeTypeValue): string;
+    UPLOAD_ACTIVITY_STATUS(uploadTime: number, activityId: string): string;
+    get IMPORT_DATA(): string;
+    get DAILY_STEPS(): string;
+    get DAILY_SLEEP(): string;
+    get DAILY_WEIGHT(): string;
+    get UPDATE_WEIGHT(): string;
+    get DAILY_HYDRATION(): string;
+    get HYDRATION_LOG(): string;
+    get GOLF_SCORECARD_SUMMARY(): string;
+    get GOLF_SCORECARD_DETAIL(): string;
+    get DAILY_HEART_RATE(): string;
+    WORKOUT(id?: GCWorkoutId): string;
+    get WORKOUTS(): string;
+}
+
+declare class HttpClient {
+    client: AxiosInstance;
+    url: UrlClass;
+    oauth1Token: IOauth1Token | undefined;
+    oauth2Token: IOauth2Token | undefined;
+    OAUTH_CONSUMER: IOauth1Consumer | undefined;
+    constructor(url: UrlClass);
+    fetchOauthConsumer(): Promise<void>;
+    checkTokenVaild(): Promise<void>;
+    get<T>(url: string, config?: AxiosRequestConfig<any>): Promise<T>;
+    post<T>(url: string, data: any, config?: AxiosRequestConfig<any>): Promise<T>;
+    put<T>(url: string, data: any, config?: AxiosRequestConfig<any>): Promise<T>;
+    delete<T>(url: string, config?: AxiosRequestConfig<any>): Promise<T>;
+    setCommonHeader(headers: RawAxiosRequestHeaders): void;
+    handleError(response: AxiosResponse): void;
+    handleHttpError(response: AxiosResponse): void;
+    /**
+     * Login to Garmin Connect
+     * @param username
+     * @param password
+     * @returns {Promise<HttpClient>}
+     */
+    login(username: string, password: string): Promise<HttpClient>;
+    private getLoginTicket;
+    handleMFA(htmlStr: string): void;
+    handlePageTitle(htmlStr: string): void;
+    handleAccountLocked(htmlStr: string): void;
+    refreshOauth2Token(): Promise<void>;
+    getOauth1Token(ticket: string): Promise<IOauth1>;
+    getOauthClient(consumer: IOauth1Consumer): OAuth$1;
+    exchange(oauth1: IOauth1): Promise<void>;
+    setOauth2TokenExpiresAt(token: IOauth2Token): IOauth2Token;
+}
+
+interface ISportType {
+    sportTypeId: number;
+    sportTypeKey: SportTypeKey;
+}
+declare enum SportTypeKey {
+    running = "running"
+}
+interface IRunningWorkout {
+    workoutId: string | undefined;
+    description: string | undefined;
+    sportType: ISportType;
+    workoutName: string;
+    workoutSegments: IWorkoutSegment[];
+}
+interface IWorkoutSegment {
+    segmentOrder: number;
+    sportType: ISportType;
+    workoutSteps: IWorkoutStep[];
+}
+interface IWorkoutStep {
+    type: WorkoutStepType;
+    stepId: unknown;
+    stepOrder: number;
+    childStepId: unknown;
+    description: string | null;
+    stepType: IStepType;
+    endCondition: IEndCondition;
+    preferredEndConditionUnit: IPreferredEndConditionUnit;
+    endConditionValue: number | null;
+    endConditionCompare: null;
+    endConditionZone: null;
+    targetType: ITargetType;
+    targetValueOne: null;
+    targetValueTwo: null;
+    zoneNumber: null;
+}
+declare enum WorkoutStepType {
+    executableStepDTO = "ExecutableStepDTO"
+}
+interface IStepType {
+    stepTypeId: number;
+    stepTypeKey: StepTypeKey;
+}
+declare enum StepTypeKey {
+    interval = "interval"
+}
+interface IEndCondition {
+    conditionTypeKey: ConditionTypeKey;
+    conditionTypeId: number;
+}
+declare enum ConditionTypeKey {
+    distance = "distance"
+}
+interface IPreferredEndConditionUnit {
+    unitKey: UnitKey;
+}
+declare enum UnitKey {
+    kilometer = "kilometer"
+}
+interface ITargetType {
+    workoutTargetTypeId: number;
+    workoutTargetTypeKey: WorkoutTargetTypeKey;
+}
+declare enum WorkoutTargetTypeKey {
+    noTarget = "no.target"
+}
+
+declare class Running {
+    private data;
+    constructor();
+    get name(): string;
+    set name(name: string);
+    get distance(): number;
+    set distance(meters: number);
+    get workoutId(): string | undefined;
+    set workoutId(workoutId: string | undefined);
+    get description(): string | undefined;
+    set description(description: string | undefined);
+    isValid(): boolean;
+    toJson(): IRunningWorkout;
+    toString(): string;
+}
+
+interface SleepDTO {
+    id: number;
+    userProfilePK: number;
+    calendarDate: string;
+    sleepTimeSeconds: number;
+    napTimeSeconds: number;
+    sleepWindowConfirmed: boolean;
+    sleepWindowConfirmationType: string;
+    sleepStartTimestampGMT: number;
+    sleepEndTimestampGMT: number;
+    sleepStartTimestampLocal: number;
+    sleepEndTimestampLocal: number;
+    autoSleepStartTimestampGMT: number | null;
+    autoSleepEndTimestampGMT: number | null;
+    sleepQualityTypePK: number | null;
+    sleepResultTypePK: number | null;
+    unmeasurableSleepSeconds: number;
+    deepSleepSeconds: number;
+    lightSleepSeconds: number;
+    remSleepSeconds: number;
+    awakeSleepSeconds: number;
+    deviceRemCapable: boolean;
+    retro: boolean;
+    sleepFromDevice: boolean;
+    averageRespirationValue: number;
+    lowestRespirationValue: number;
+    highestRespirationValue: number;
+    awakeCount: number;
+    avgSleepStress: number;
+    ageGroup: string;
+    sleepScoreFeedback: string;
+    sleepScoreInsight: string;
+    sleepScores: {
+        totalDuration: {
+            qualifierKey: string;
+            optimalStart: number;
+            optimalEnd: number;
+        };
+        stress: {
+            qualifierKey: string;
+            optimalStart: number;
+            optimalEnd: number;
+        };
+        awakeCount: {
+            qualifierKey: string;
+            optimalStart: number;
+            optimalEnd: number;
+        };
+        overall: {
+            value: number;
+            qualifierKey: string;
+        };
+        remPercentage: {
+            value: number;
+            qualifierKey: string;
+            optimalStart: number;
+            optimalEnd: number;
+            idealStartInSeconds: number;
+            idealEndInSeconds: number;
+        };
+        restlessness: {
+            qualifierKey: string;
+            optimalStart: number;
+            optimalEnd: number;
+        };
+        lightPercentage: {
+            value: number;
+            qualifierKey: string;
+            optimalStart: number;
+            optimalEnd: number;
+            idealStartInSeconds: number;
+            idealEndInSeconds: number;
+        };
+        deepPercentage: {
+            value: number;
+            qualifierKey: string;
+            optimalStart: number;
+            optimalEnd: number;
+            idealStartInSeconds: number;
+            idealEndInSeconds: number;
+        };
+    };
+    sleepVersion: number;
+}
+interface SleepMovement {
+    startGMT: string;
+    endGMT: string;
+    activityLevel: number;
+}
+interface SleepLevels {
+    startGMT: string;
+    endGMT: string;
+    activityLevel: number;
+}
+interface WellnessEpochRespirationDataDTO {
+    startTimeGMT: number;
+    respirationValue: number;
+}
+interface SleepHeartRate {
+    value: number;
+    startGMT: number;
+}
+interface SleepBodyBattery {
+    value: number;
+    startGMT: number;
+}
+interface SleepData {
+    dailySleepDTO: SleepDTO;
+    sleepMovement: SleepMovement[];
+    remSleepData: boolean;
+    sleepLevels: SleepLevels[];
+    restlessMomentsCount: number;
+    wellnessEpochRespirationDataDTOList: WellnessEpochRespirationDataDTO[];
+    sleepHeartRate: SleepHeartRate[];
+    sleepBodyBattery: SleepBodyBattery[];
+    avgOvernightHrv: number;
+    hrvStatus: string;
+    bodyBatteryChange: number;
+    restingHeartRate: number;
+}
+
+interface DateWeight {
+    samplePk: number;
+    date: number;
+    calendarDate: string;
+    weight: number;
+    bmi: number | null;
+    bodyFat: number | null;
+    bodyWater: number | null;
+    boneMass: number | null;
+    muscleMass: number | null;
+    physiqueRating: number | null;
+    visceralFat: number | null;
+    metabolicAge: number | null;
+    sourceType: string;
+    timestampGMT: number;
+    weightDelta: number;
+}
+interface TotalAverage {
+    from: number;
+    until: number;
+    weight: number;
+    bmi: number | null;
+    bodyFat: number | null;
+    bodyWater: number | null;
+    boneMass: number | null;
+    muscleMass: number | null;
+    physiqueRating: number | null;
+    visceralFat: number | null;
+    metabolicAge: number | null;
+}
+interface WeightData {
+    startDate: string;
+    endDate: string;
+    dateWeightList: DateWeight[];
+    totalAverage: TotalAverage;
+}
+interface UpdateWeight {
+    dateTimestamp: string;
+    gmtTimestamp: string;
+    unitKey: string;
+    value: number;
+}
+
+interface WaterIntake {
+    userId: number;
+    calendarDate: string;
+    valueInML: number;
+    goalInML: number;
+    dailyAverageinML: number | null;
+    lastEntryTimestampLocal: string;
+    sweatLossInML: number | null;
+    activityIntakeInML: number;
+}
+
+interface ScorecardSummary {
+    id: number;
+    customerId: string;
+    playerProfileId: number;
+    scoreType: string;
+    courseName: string;
+    startTime: string;
+    endTime: string;
+    roundInProgress: boolean;
+    strokes: number;
+    handicappedStrokes: number;
+    scoreWithHandicap: number;
+    scoreWithoutHandicap: number;
+    holesCompleted: number;
+    roundType: string;
+}
+interface GolfSummary {
+    pageNumber: number;
+    rowsPerPage: number;
+    totalRows: number;
+    scorecardSummaries: ScorecardSummary[];
+}
+interface GolfScorecard {
+    id: number;
+    customerId: string;
+    playerProfileId: number;
+    roundPlayerName: string;
+    connectDisplayName: string;
+    courseGlobalId: number;
+    courseSnapshotId: number;
+    frontNineGlobalCourseId: number;
+    scoreType: string;
+    useHandicapScoring: boolean;
+    useStrokeCounting: boolean;
+    distanceWalked: number;
+    stepsTaken: number;
+    startTime: string;
+    formattedStartTime: string;
+    endTime: string;
+    formattedEndTime: string;
+    unitId: string;
+    roundType: string;
+    inProgress: boolean;
+    excludeFromStats: boolean;
+    holesCompleted: number;
+    publicRound: boolean;
+    score: number;
+    playerHandicap: number;
+    courseHandicapStr: string;
+    teeBox: string;
+    handicapType: string;
+    teeBoxRating: number;
+    teeBoxSlope: number;
+    lastModifiedDt: string;
+    sensorOnPutter: boolean;
+    handicappedStrokes: number;
+}
+
+interface HeartRateValueDescriptor {
+    key: string;
+    index: number;
+}
+interface HeartRateEntry {
+    timestamp: number;
+    heartrate: number;
+}
+interface HeartRate {
+    userProfilePK: number;
+    calendarDate: string;
+    startTimestampGMT: string;
+    endTimestampGMT: string;
+    startTimestampLocal: string;
+    endTimestampLocal: string;
+    maxHeartRate: number;
+    minHeartRate: number;
+    restingHeartRate: number;
+    lastSevenDaysAvgRestingHeartRate: number;
+    heartRateValueDescriptors: HeartRateValueDescriptor[];
+    heartRateValues: HeartRateEntry[][];
+}
+
+interface GCCredentials {
+    username: string;
+    password: string;
+}
+declare class GarminConnect {
+    client: HttpClient;
+    private _userHash;
+    private credentials;
+    private listeners;
+    private url;
+    constructor(credentials?: GCCredentials | undefined, domain?: GarminDomain);
+    login(username?: string, password?: string): Promise<GarminConnect>;
+    exportTokenToFile(dirPath: string): void;
+    loadTokenByFile(dirPath: string): void;
+    exportToken(): IGarminTokens;
+    loadToken(oauth1: IOauth1Token, oauth2: IOauth2Token): void;
+    getUserSettings(): Promise<IUserSettings>;
+    getUserProfile(): Promise<ISocialProfile>;
+    getActivities(start?: number, limit?: number, activityType?: ActivityType, subActivityType?: ActivitySubType): Promise<IActivity[]>;
+    getActivity(activity: {
+        activityId: GCActivityId;
+    }): Promise<IActivityDetails>;
+    countActivities(): Promise<ICountActivities>;
+    createGear(payload: {
+        createDate: Date;
+        customMakeModel: string;
+        dateBegin: Date;
+        displayName: string;
+        gearMakeName: string;
+        gearModelName: string;
+        maximumMeters: number;
+    }): Promise<Gear>;
+    getGears(userProfilePk: string | number): Promise<Gear[]>;
+    getActivityGear(activityId: string): Promise<Gear[]>;
+    linkActivityGear(gearUuid: GCGearUuid, activityId: GCActivityId): Promise<Gear>;
+    unlinkActivityGear(gearUuid: GCGearUuid, activityId: GCActivityId): Promise<Gear>;
+    changeGearStatus(userProfileId: string | number, gearUuid: GCGearUuid, data: {
+        status: GearStatus.RETIRED;
+        dateEnd: Date;
+    } | {
+        status: GearStatus.ACTIVE;
+    }): Promise<Gear>;
+    downloadOriginalActivityData(activity: {
+        activityId: GCActivityId;
+    }, dir: string, type?: ExportFileTypeValue): Promise<void>;
+    uploadActivity(file: string, format?: UploadFileTypeTypeValue): Promise<IActivityUploadDetails>;
+    getUploadActivityDetails(uploadCreationDate: string, activityId: string): Promise<IActivityUploadDetails>;
+    deleteActivity(activity: {
+        activityId: GCActivityId;
+    }): Promise<void>;
+    getWorkouts(start: number, limit: number): Promise<IWorkout[]>;
+    getWorkoutDetail(workout: {
+        workoutId: string;
+    }): Promise<IWorkoutDetail>;
+    addWorkout(workout: IWorkoutDetail | Running): Promise<IWorkoutDetail>;
+    addRunningWorkout(name: string, meters: number, description: string): Promise<IWorkoutDetail>;
+    deleteWorkout(workout: {
+        workoutId: string;
+    }): Promise<unknown>;
+    addActivity(activity: INewActivity): Promise<IActivity>;
+    getSteps(date?: Date): Promise<number>;
+    getSleepData(date?: Date): Promise<SleepData>;
+    getSleepDuration(date?: Date): Promise<{
+        hours: number;
+        minutes: number;
+    }>;
+    getDailyWeightData(date?: Date): Promise<WeightData>;
+    getDailyWeightInPounds(date?: Date): Promise<number>;
+    getDailyHydration(date?: Date): Promise<number>;
+    updateWeight(date: Date, lbs: number, timezone: string): Promise<UpdateWeight>;
+    updateHydrationLogOunces(date: Date, valueInOz: number): Promise<WaterIntake>;
+    getGolfSummary(): Promise<GolfSummary>;
+    getGolfScorecard(scorecardId: number): Promise<GolfScorecard>;
+    getHeartRate(date?: Date): Promise<HeartRate>;
+    get<T>(url: string, data?: any): Promise<T>;
+    post<T>(url: string, data: any): Promise<T>;
+    put<T>(url: string, data: any): Promise<T>;
+}
+
+export { ActivitySubType, ActivityType, GarminConnect, type Gear, GearStatus, type IActivity, type IActivityDetails };
diff --git a/dist/index.d.ts b/dist/index.d.ts
index e38e9cc05dd81ea98991caad686af9341a3c87d3..1390408a1a2e1262ea4bfd58bb806b307169a8a6 100644
--- a/dist/index.d.ts
+++ b/dist/index.d.ts
@@ -1 +1,1320 @@
-export { default as GarminConnect } from './garmin/GarminConnect';
+import { AxiosInstance, AxiosRequestConfig, RawAxiosRequestHeaders, AxiosResponse } from 'axios';
+import OAuth$1 from 'oauth-1.0a';
+
+type GCUserProfileId = number;
+type GCUserHash = string;
+type GCWorkoutId = string;
+type GCGearId = number;
+type GCGearUuid = string;
+type GarminDomain = 'garmin.com' | 'garmin.cn';
+declare enum ExportFileType {
+    tcx = "tcx",
+    gpx = "gpx",
+    kml = "kml",
+    zip = "zip"
+}
+declare enum UploadFileType {
+    tcx = "tcx",
+    gpx = "gpx",
+    fit = "fit"
+}
+type ExportFileTypeValue = keyof typeof ExportFileType;
+type UploadFileTypeTypeValue = keyof typeof UploadFileType;
+interface ISocialProfile {
+    id: number;
+    profileId: GCUserProfileId;
+    garminGUID: string;
+    displayName: GCUserHash;
+    fullName: string;
+    userName: string;
+    profileImageUuid: unknown;
+    profileImageUrlLarge: string;
+    profileImageUrlMedium: string;
+    profileImageUrlSmall: string;
+    location: string;
+    facebookUrl: unknown;
+    twitterUrl: unknown;
+    personalWebsite: unknown;
+    motivation: unknown;
+    bio: unknown;
+    primaryActivity: unknown;
+    favoriteActivityTypes: unknown[];
+    runningTrainingSpeed: number;
+    cyclingTrainingSpeed: number;
+    favoriteCyclingActivityTypes: unknown[];
+    cyclingClassification: unknown;
+    cyclingMaxAvgPower: number;
+    swimmingTrainingSpeed: number;
+    profileVisibility: string;
+    activityStartVisibility: string;
+    activityMapVisibility: string;
+    courseVisibility: string;
+    activityHeartRateVisibility: string;
+    activityPowerVisibility: string;
+    badgeVisibility: string;
+    showAge: boolean;
+    showWeight: boolean;
+    showHeight: boolean;
+    showWeightClass: boolean;
+    showAgeRange: boolean;
+    showGender: boolean;
+    showActivityClass: boolean;
+    showVO2Max: boolean;
+    showPersonalRecords: boolean;
+    showLast12Months: boolean;
+    showLifetimeTotals: boolean;
+    showUpcomingEvents: boolean;
+    showRecentFavorites: boolean;
+    showRecentDevice: boolean;
+    showRecentGear: boolean;
+    showBadges: boolean;
+    otherActivity: null;
+    otherPrimaryActivity: null;
+    otherMotivation: null;
+    userRoles: string[];
+    nameApproved: boolean;
+    userProfileFullName: string;
+    makeGolfScorecardsPrivate: boolean;
+    allowGolfLiveScoring: boolean;
+    allowGolfScoringByConnections: boolean;
+    userLevel: number;
+    userPoint: number;
+    levelUpdateDate: string;
+    levelIsViewed: boolean;
+    levelPointThreshold: number;
+    userPointOffset: number;
+    userPro: boolean;
+}
+declare enum GearStatus {
+    ACTIVE = "active",
+    RETIRED = "retired"
+}
+interface Gear {
+    gearPk: GCGearId;
+    uuid: GCGearUuid;
+    userProfilePk: GCUserProfileId;
+    gearMakeName: string;
+    gearModelName: string;
+    gearTypeName: 'Shoes' | 'Bike' | 'Other' | string;
+    gearStatusName: GearStatus;
+    displayName: string | null;
+    customMakeModel: string;
+    imageNameLarge: string | null;
+    imageNameMedium: string | null;
+    imageNameSmall: string | null;
+    dateBegin: string;
+    dateEnd: string | null;
+    maximumMeters: number;
+    notified: boolean;
+    createDate: string;
+    updateDate: string;
+}
+interface IOauth1Consumer {
+    key: string;
+    secret: string;
+}
+interface IOauth1 {
+    token: IOauth1Token;
+    oauth: OAuth;
+}
+interface IGarminTokens {
+    oauth1: IOauth1Token;
+    oauth2: IOauth2Token;
+}
+interface IOauth1Token {
+    oauth_token: string;
+    oauth_token_secret: string;
+}
+interface IOauth2Token {
+    scope: string;
+    jti: string;
+    access_token: string;
+    token_type: string;
+    refresh_token: string;
+    expires_in: number;
+    refresh_token_expires_in: number;
+    expires_at: number;
+    refresh_token_expires_at: number;
+    last_update_date: string;
+    expires_date: string;
+}
+interface IUserSettings {
+    id: number;
+    userData: IUserData;
+    userSleep: {
+        sleepTime: number;
+        defaultSleepTime: boolean;
+        wakeTime: number;
+        defaultWakeTime: boolean;
+    };
+    connectDate: unknown;
+    sourceType: unknown;
+    userSleepWindows: IUserSleepWindows[];
+}
+interface IUserData {
+    gender: unknown;
+    weight: unknown;
+    height: unknown;
+    timeFormat: string;
+    birthDate: unknown;
+    measurementSystem: string;
+    activityLevel: unknown;
+    handedness: string;
+    powerFormat: {
+        formatId: number;
+        formatKey: string;
+        minFraction: number;
+        maxFraction: number;
+        groupingUsed: boolean;
+        displayFormat: unknown;
+    };
+    heartRateFormat: {
+        formatId: number;
+        formatKey: string;
+        minFraction: number;
+        maxFraction: number;
+        groupingUsed: boolean;
+        displayFormat: unknown;
+    };
+    firstDayOfWeek: {
+        dayId: number;
+        dayName: string;
+        sortOrder: number;
+        isPossibleFirstDay: boolean;
+    };
+    vo2MaxRunning: unknown;
+    vo2MaxCycling: unknown;
+    lactateThresholdSpeed: unknown;
+    lactateThresholdHeartRate: unknown;
+    diveNumber: unknown;
+    intensityMinutesCalcMethod: string;
+    moderateIntensityMinutesHrZone: number;
+    vigorousIntensityMinutesHrZone: number;
+    hydrationMeasurementUnit: string;
+    hydrationContainers: unknown[];
+    hydrationAutoGoalEnabled: boolean;
+    firstbeatMaxStressScore: unknown;
+    firstbeatCyclingLtTimestamp: unknown;
+    firstbeatRunningLtTimestamp: unknown;
+    thresholdHeartRateAutoDetected: unknown;
+    ftpAutoDetected: unknown;
+    trainingStatusPausedDate: unknown;
+    weatherLocation: {
+        useFixedLocation: unknown;
+        latitude: unknown;
+        longitude: unknown;
+        locationName: unknown;
+        isoCountryCode: unknown;
+        postalCode: unknown;
+    };
+    golfDistanceUnit: string;
+    golfElevationUnit: unknown;
+    golfSpeedUnit: unknown;
+    externalBottomTime: unknown;
+}
+interface IUserSleepWindows {
+    sleepWindowFrequency: string;
+    startSleepTimeSecondsFromMidnight: number;
+    endSleepTimeSecondsFromMidnight: number;
+}
+interface ICountActivities {
+    countOfActivities: number;
+    date: string;
+    stats: {
+        all: Record<string, any>;
+    };
+}
+interface IWorkout {
+    workoutId?: number;
+    ownerId?: number;
+    workoutName: string;
+    description?: string;
+    updateDate: Date;
+    createdDate: Date;
+    sportType: ISportType$1;
+    trainingPlanId: null;
+    author: IAuthor;
+    estimatedDurationInSecs: number;
+    estimatedDistanceInMeters: null;
+    estimateType: null;
+    estimatedDistanceUnit: IUnit;
+    poolLength: number;
+    poolLengthUnit: IUnit;
+    workoutProvider: string;
+    workoutSourceId: string;
+    consumer: null;
+    atpPlanId: null;
+    workoutNameI18nKey: null;
+    descriptionI18nKey: null;
+    shared: boolean;
+    estimated: boolean;
+}
+interface IWorkoutDetail extends IWorkout {
+    workoutSegments: IWorkoutSegment$1[];
+}
+interface IAuthor {
+    userProfilePk: null;
+    displayName: null;
+    fullName: null;
+    profileImgNameLarge: null;
+    profileImgNameMedium: null;
+    profileImgNameSmall: null;
+    userPro: boolean;
+    vivokidUser: boolean;
+}
+interface IUnit {
+    unitId: null;
+    unitKey: null;
+    factor: null;
+}
+interface ISportType$1 {
+    sportTypeId: number;
+    sportTypeKey: string;
+    displayOrder?: number;
+}
+interface IWorkoutSegment$1 {
+    segmentOrder: number;
+    sportType: ISportType$1;
+    workoutSteps: IWorkoutStep$1[];
+}
+interface IWorkoutStep$1 {
+    type: string;
+    stepId: number;
+    stepOrder: number;
+    stepType: IStepType$1;
+    childStepId: null;
+    description: null;
+    endCondition: IEndCondition$1;
+    endConditionValue: number | null;
+    preferredEndConditionUnit: IUnit | null;
+    endConditionCompare: null;
+    targetType: ITargetType$1;
+    targetValueOne: null;
+    targetValueTwo: null;
+    targetValueUnit: null;
+    zoneNumber: null;
+    secondaryTargetType: null;
+    secondaryTargetValueOne: null;
+    secondaryTargetValueTwo: null;
+    secondaryTargetValueUnit: null;
+    secondaryZoneNumber: null;
+    endConditionZone: null;
+    strokeType: IStrokeType;
+    equipmentType: IEquipmentType;
+    category: null;
+    exerciseName: null;
+    workoutProvider: null;
+    providerExerciseSourceId: null;
+    weightValue: null;
+    weightUnit: null;
+}
+interface IEndCondition$1 {
+    conditionTypeId: number;
+    conditionTypeKey: string;
+    displayOrder: number;
+    displayable: boolean;
+}
+interface IEquipmentType {
+    equipmentTypeId: number;
+    equipmentTypeKey: null;
+    displayOrder: number;
+}
+interface IStepType$1 {
+    stepTypeId: number;
+    stepTypeKey: string;
+    displayOrder: number;
+}
+interface IStrokeType {
+    strokeTypeId: number;
+    strokeTypeKey: null;
+    displayOrder: number;
+}
+interface ITargetType$1 {
+    workoutTargetTypeId: number;
+    workoutTargetTypeKey: string;
+    displayOrder: number;
+}
+
+type GCActivityId = number;
+declare enum ActivityType {
+    Cycling = "cycling",
+    FitnessEquipment = "fitness_equipment",
+    Walking = "walking",
+    Hiking = "hiking",
+    Other = "other",
+    WaterSport = "water_sports",
+    Running = "running"
+}
+declare enum ActivitySubType {
+    IndoorCardio = "indoor_cardio",// Maps to FitnessEquipment
+    StrengthTraining = "strength_training",// Maps to FitnessEquipment
+    HIIT = "hiit",// Maps to FitnessEquipment
+    Yoga = "yoga",// Maps to FitnessEquipment
+    IndoorCycling = "indoor_cycling",// Maps to Cycling
+    Breathwork = "breathwork",// Maps to Other
+    Surfing = "surfing",// Maps to WaterSport
+    StreetRunning = "street_running",// Maps to Running
+    TrailRunning = "trail_running",// Maps to Running
+    IndoorRunning = "indoor_running"
+}
+interface IActivityUploadDetails {
+    detailedImportResult: {
+        uploadId: number;
+        uploadUuid: {
+            uuid: string;
+        };
+        owner: GCUserProfileId;
+        fileSize: number;
+        processingTime: number;
+        creationDate: string;
+        ipAddress: string | null;
+        fileName: string;
+        report: string | null;
+        successes: {
+            internalId: number;
+            externalId: string | null;
+            messages: {
+                code: number;
+                content: string;
+            }[] | null;
+        }[];
+        failures: {
+            internalId: number;
+            externalId: string | null;
+            messages: {
+                code: number;
+                content: string;
+            }[] | null;
+        }[];
+    };
+}
+interface IActivity {
+    activityId: GCActivityId;
+    activityName: string;
+    description: unknown;
+    startTimeLocal: string;
+    startTimeGMT: string;
+    activityType: {
+        typeId: number;
+        typeKey: string;
+        parentTypeId: number;
+        isHidden: boolean;
+        sortOrder: unknown;
+        trimmable: boolean;
+        restricted: boolean;
+    };
+    eventType: {
+        typeId: number;
+        typeKey: string;
+        sortOrder: number;
+    };
+    comments: unknown;
+    parentId: unknown;
+    distance: number;
+    duration: number;
+    elapsedDuration: number;
+    movingDuration: number;
+    elevationGain: number;
+    elevationLoss: number;
+    averageSpeed: number;
+    maxSpeed: number;
+    startLatitude: number;
+    startLongitude: number;
+    hasPolyline: boolean;
+    ownerId: number;
+    ownerDisplayName: string;
+    ownerFullName: string;
+    ownerProfileImageUrlSmall: string;
+    ownerProfileImageUrlMedium: string;
+    ownerProfileImageUrlLarge: string;
+    calories: number;
+    averageHR: number;
+    maxHR: number;
+    averageRunningCadenceInStepsPerMinute: number;
+    maxRunningCadenceInStepsPerMinute: number;
+    averageBikingCadenceInRevPerMinute: unknown;
+    maxBikingCadenceInRevPerMinute: unknown;
+    averageSwimCadenceInStrokesPerMinute: unknown;
+    maxSwimCadenceInStrokesPerMinute: unknown;
+    averageSwolf: unknown;
+    activeLengths: unknown;
+    steps: number;
+    conversationUuid: unknown;
+    conversationPk: unknown;
+    numberOfActivityLikes: unknown;
+    numberOfActivityComments: unknown;
+    likedByUser: unknown;
+    commentedByUser: unknown;
+    activityLikeDisplayNames: unknown;
+    activityLikeFullNames: unknown;
+    activityLikeProfileImageUrls: unknown;
+    requestorRelationship: unknown;
+    userRoles: string[];
+    privacy: {
+        typeId: number;
+        typeKey: string;
+    };
+    userPro: boolean;
+    courseId: unknown;
+    poolLength: unknown;
+    unitOfPoolLength: unknown;
+    hasVideo: boolean;
+    videoUrl: unknown;
+    timeZoneId: number;
+    beginTimestamp: number;
+    sportTypeId: number;
+    avgPower: unknown;
+    maxPower: unknown;
+    aerobicTrainingEffect: unknown;
+    anaerobicTrainingEffect: unknown;
+    strokes: unknown;
+    normPower: unknown;
+    leftBalance: unknown;
+    rightBalance: unknown;
+    avgLeftBalance: unknown;
+    max20MinPower: unknown;
+    avgVerticalOscillation: unknown;
+    avgGroundContactTime: unknown;
+    avgStrideLength: number;
+    avgFractionalCadence: unknown;
+    maxFractionalCadence: unknown;
+    trainingStressScore: unknown;
+    intensityFactor: unknown;
+    vO2MaxValue: number;
+    avgVerticalRatio: unknown;
+    avgGroundContactBalance: unknown;
+    lactateThresholdBpm: unknown;
+    lactateThresholdSpeed: unknown;
+    maxFtp: unknown;
+    avgStrokeDistance: unknown;
+    avgStrokeCadence: unknown;
+    maxStrokeCadence: unknown;
+    workoutId: unknown;
+    avgStrokes: unknown;
+    minStrokes: unknown;
+    deviceId: number;
+    minTemperature: unknown;
+    maxTemperature: unknown;
+    minElevation: number;
+    maxElevation: number;
+    avgDoubleCadence: unknown;
+    maxDoubleCadence: number;
+    summarizedExerciseSets: unknown;
+    maxDepth: unknown;
+    avgDepth: unknown;
+    surfaceInterval: unknown;
+    startN2: unknown;
+    endN2: unknown;
+    startCns: unknown;
+    endCns: unknown;
+    summarizedDiveInfo: {
+        weight: unknown;
+        weightUnit: unknown;
+        visibility: unknown;
+        visibilityUnit: unknown;
+        surfaceCondition: unknown;
+        current: unknown;
+        waterType: unknown;
+        waterDensity: unknown;
+        summarizedDiveGases: [];
+        totalSurfaceTime: unknown;
+    };
+    activityLikeAuthors: unknown;
+    avgVerticalSpeed: unknown;
+    maxVerticalSpeed: number;
+    floorsClimbed: unknown;
+    floorsDescended: unknown;
+    manufacturer: string;
+    diveNumber: unknown;
+    locationName: string;
+    bottomTime: unknown;
+    lapCount: number;
+    endLatitude: number;
+    endLongitude: number;
+    minAirSpeed: unknown;
+    maxAirSpeed: unknown;
+    avgAirSpeed: unknown;
+    avgWindYawAngle: unknown;
+    minCda: unknown;
+    maxCda: unknown;
+    avgCda: unknown;
+    avgWattsPerCda: unknown;
+    flow: unknown;
+    grit: unknown;
+    jumpCount: unknown;
+    caloriesEstimated: unknown;
+    caloriesConsumed: unknown;
+    waterEstimated: unknown;
+    waterConsumed: unknown;
+    maxAvgPower_1: unknown;
+    maxAvgPower_2: unknown;
+    maxAvgPower_5: unknown;
+    maxAvgPower_10: unknown;
+    maxAvgPower_20: unknown;
+    maxAvgPower_30: unknown;
+    maxAvgPower_60: unknown;
+    maxAvgPower_120: unknown;
+    maxAvgPower_300: unknown;
+    maxAvgPower_600: unknown;
+    maxAvgPower_1200: unknown;
+    maxAvgPower_1800: unknown;
+    maxAvgPower_3600: unknown;
+    maxAvgPower_7200: unknown;
+    maxAvgPower_18000: unknown;
+    excludeFromPowerCurveReports: unknown;
+    totalSets: unknown;
+    activeSets: unknown;
+    totalReps: unknown;
+    minRespirationRate: unknown;
+    maxRespirationRate: unknown;
+    avgRespirationRate: unknown;
+    trainingEffectLabel: unknown;
+    activityTrainingLoad: unknown;
+    avgFlow: unknown;
+    avgGrit: unknown;
+    minActivityLapDuration: number;
+    avgStress: unknown;
+    startStress: unknown;
+    endStress: unknown;
+    differenceStress: unknown;
+    maxStress: unknown;
+    aerobicTrainingEffectMessage: unknown;
+    anaerobicTrainingEffectMessage: unknown;
+    splitSummaries: [];
+    hasSplits: boolean;
+    maxBottomTime: unknown;
+    hasSeedFirstbeatProfile: unknown;
+    calendarEventId: unknown;
+    calendarEventUuid: unknown;
+    avgGradeAdjustedSpeed: unknown;
+    avgWheelchairCadence: unknown;
+    maxWheelchairCadence: unknown;
+    purposeful: boolean;
+    manualActivity: boolean;
+    autoCalcCalories: boolean;
+    elevationCorrected: boolean;
+    atpActivity: boolean;
+    favorite: boolean;
+    decoDive: unknown;
+    pr: boolean;
+    parent: boolean;
+}
+interface IActivityDetails {
+    activityId: number;
+    activityUUID: {
+        uuid: string;
+    };
+    activityName: string;
+    userProfileId: number;
+    isMultiSportParent: boolean;
+    activityTypeDTO: {
+        typeId: number;
+        typeKey: string;
+        parentTypeId: number;
+        isHidden: boolean;
+        restricted: boolean;
+        trimmable: boolean;
+    };
+    eventTypeDTO: {
+        typeId: number;
+        typeKey: string;
+        sortOrder: number;
+    };
+    accessControlRuleDTO: {
+        typeId: number;
+        typeKey: string;
+    };
+    timeZoneUnitDTO: {
+        unitId: number;
+        unitKey: string;
+        factor: number;
+        timeZone: string;
+    };
+    metadataDTO: {
+        isOriginal: boolean;
+        deviceApplicationInstallationId: number;
+        agentApplicationInstallationId?: null;
+        agentString?: null;
+        fileFormat: {
+            formatId: number;
+            formatKey: string;
+        };
+        associatedCourseId?: null;
+        lastUpdateDate: string;
+        uploadedDate: string;
+        videoUrl?: null;
+        hasPolyline: boolean;
+        hasChartData: boolean;
+        hasHrTimeInZones: boolean;
+        hasPowerTimeInZones: boolean;
+        userInfoDto: {
+            userProfilePk: number;
+            displayname: string;
+            fullname: string;
+            profileImageUrlLarge?: null;
+            profileImageUrlMedium: string;
+            profileImageUrlSmall: string;
+            userPro: boolean;
+        };
+        childIds?: null[] | null;
+        childActivityTypes?: null[] | null;
+        sensors?: {
+            manufacturer: string;
+            serialNumber: number;
+            sku: string;
+            fitProductNumber: number;
+            sourceType: string;
+            antplusDeviceType: string;
+            softwareVersion: number;
+            batteryStatus: string;
+        }[] | null;
+        activityImages?: {
+            imageId: string;
+            url: string;
+            smallUrl: string;
+            mediumUrl: string;
+            expirationTimestamp?: null;
+            latitude?: null;
+            longitude?: null;
+            photoDate?: null;
+        }[] | null;
+        manufacturer: string;
+        diveNumber?: null;
+        lapCount: number;
+        associatedWorkoutId: number;
+        isAtpActivity?: null;
+        deviceMetaDataDTO: {
+            deviceId: string;
+            deviceTypePk: number;
+            deviceVersionPk: number;
+        };
+        hasIntensityIntervals: boolean;
+        hasSplits: boolean;
+        eBikeMaxAssistModes?: null;
+        eBikeBatteryUsage?: null;
+        eBikeBatteryRemaining?: null;
+        eBikeAssistModeInfoDTOList?: null;
+        calendarEventInfo?: null;
+        personalRecord: boolean;
+        gcj02: boolean;
+        runPowerWindDataEnabled?: null;
+        autoCalcCalories: boolean;
+        favorite: boolean;
+        manualActivity: boolean;
+        trimmed: boolean;
+        elevationCorrected: boolean;
+    };
+    summaryDTO: {
+        startTimeLocal: string;
+        startTimeGMT: string;
+        startLatitude: number;
+        startLongitude: number;
+        distance: number;
+        duration: number;
+        movingDuration: number;
+        elapsedDuration: number;
+        elevationGain: number;
+        elevationLoss: number;
+        maxElevation: number;
+        minElevation: number;
+        averageSpeed: number;
+        averageMovingSpeed: number;
+        maxSpeed: number;
+        calories: number;
+        averageHR: number;
+        maxHR: number;
+        averageRunCadence: number;
+        maxRunCadence: number;
+        averageTemperature: number;
+        maxTemperature: number;
+        minTemperature: number;
+        groundContactTime: number;
+        groundContactBalanceLeft: number;
+        strideLength: number;
+        verticalOscillation: number;
+        trainingEffect: number;
+        anaerobicTrainingEffect: number;
+        aerobicTrainingEffectMessage: string;
+        anaerobicTrainingEffectMessage: string;
+        verticalRatio: number;
+        endLatitude: number;
+        endLongitude: number;
+        maxVerticalSpeed: number;
+        minActivityLapDuration: number;
+    };
+    locationName: string;
+    splitSummaries?: {
+        distance: number;
+        duration: number;
+        movingDuration: number;
+        elapsedDuration: number;
+        elevationGain: number;
+        elevationLoss: number;
+        averageSpeed: number;
+        averageMovingSpeed: number;
+        maxSpeed: number;
+        calories: number;
+        averageHR: number;
+        maxHR: number;
+        averageRunCadence: number;
+        maxRunCadence: number;
+        averageTemperature: number;
+        maxTemperature: number;
+        minTemperature: number;
+        groundContactTime: number;
+        groundContactBalanceLeft: number;
+        strideLength: number;
+        verticalOscillation: number;
+        verticalRatio: number;
+        totalExerciseReps: number;
+        splitType: string;
+        noOfSplits: number;
+        maxElevationGain: number;
+        averageElevationGain: number;
+        maxDistance: number;
+    }[] | null;
+}
+interface INewActivity {
+    accessControlRuleDTO: {
+        typeId: number;
+        typeKey: string;
+    };
+    activityName: string;
+    activityTypeDTO: {
+        typeKey: string;
+    };
+    description: string | null;
+    eventTypeDTO: {
+        typeKey: string;
+    };
+    metadataDTO: {
+        associatedCourseId: string | null;
+        autoCalcCalories: boolean;
+        videoUrl: string | null;
+    };
+    summaryDTO: {
+        averageHR: number | null;
+        averagePower: number | null;
+        averageRunCadence: number | null;
+        averageTemperature: number | null;
+        bmrCalories: number | null;
+        calories: number | null;
+        distance: number;
+        duration: number;
+        elapsedDuration: number | null;
+        elevationGain: number | null;
+        elevationLoss: number | null;
+        endLatitude: number | null;
+        endLongitude: number | null;
+        maxElevation: number | null;
+        minElevation: number | null;
+        maxHR: number | null;
+        maxRunCadence: number | null;
+        maxTemperature: number | null;
+        minTemperature: number | null;
+        movingDuration: number | null;
+        startTimeLocal: string;
+        startTimeGMT: string | null;
+        startLatitude: number | null;
+        startLongitude: number | null;
+    };
+    timeZoneUnitDTO: {
+        unitKey: string;
+    };
+}
+
+declare class UrlClass {
+    private domain;
+    GC_MODERN: string;
+    GARMIN_SSO_ORIGIN: string;
+    GC_API: string;
+    constructor(domain?: GarminDomain);
+    get GARMIN_SSO(): string;
+    get GARMIN_SSO_EMBED(): string;
+    get BASE_URL(): string;
+    get SIGNIN_URL(): string;
+    get LOGIN_URL(): string;
+    get OAUTH_URL(): string;
+    get USER_SETTINGS(): string;
+    get USER_PROFILE(): string;
+    get ACTIVITIES(): string;
+    get ACTIVITY(): string;
+    get STAT_ACTIVITIES(): string;
+    get CREATE_GEAR(): string;
+    get ACTIVITY_GEAR(): string;
+    GEAR_DATA(gearId: GCGearUuid): string;
+    ACTIVITY_GEAR_LINK(gearId: GCGearUuid, activityId: GCActivityId): string;
+    ACTIVITY_GEAR_UNLINK(gearId: GCGearUuid, activityId: GCActivityId): string;
+    get DOWNLOAD_ZIP(): string;
+    get DOWNLOAD_GPX(): string;
+    get DOWNLOAD_TCX(): string;
+    get DOWNLOAD_KML(): string;
+    UPLOAD(format: UploadFileTypeTypeValue): string;
+    UPLOAD_ACTIVITY_STATUS(uploadTime: number, activityId: string): string;
+    get IMPORT_DATA(): string;
+    get DAILY_STEPS(): string;
+    get DAILY_SLEEP(): string;
+    get DAILY_WEIGHT(): string;
+    get UPDATE_WEIGHT(): string;
+    get DAILY_HYDRATION(): string;
+    get HYDRATION_LOG(): string;
+    get GOLF_SCORECARD_SUMMARY(): string;
+    get GOLF_SCORECARD_DETAIL(): string;
+    get DAILY_HEART_RATE(): string;
+    WORKOUT(id?: GCWorkoutId): string;
+    get WORKOUTS(): string;
+}
+
+declare class HttpClient {
+    client: AxiosInstance;
+    url: UrlClass;
+    oauth1Token: IOauth1Token | undefined;
+    oauth2Token: IOauth2Token | undefined;
+    OAUTH_CONSUMER: IOauth1Consumer | undefined;
+    constructor(url: UrlClass);
+    fetchOauthConsumer(): Promise<void>;
+    checkTokenVaild(): Promise<void>;
+    get<T>(url: string, config?: AxiosRequestConfig<any>): Promise<T>;
+    post<T>(url: string, data: any, config?: AxiosRequestConfig<any>): Promise<T>;
+    put<T>(url: string, data: any, config?: AxiosRequestConfig<any>): Promise<T>;
+    delete<T>(url: string, config?: AxiosRequestConfig<any>): Promise<T>;
+    setCommonHeader(headers: RawAxiosRequestHeaders): void;
+    handleError(response: AxiosResponse): void;
+    handleHttpError(response: AxiosResponse): void;
+    /**
+     * Login to Garmin Connect
+     * @param username
+     * @param password
+     * @returns {Promise<HttpClient>}
+     */
+    login(username: string, password: string): Promise<HttpClient>;
+    private getLoginTicket;
+    handleMFA(htmlStr: string): void;
+    handlePageTitle(htmlStr: string): void;
+    handleAccountLocked(htmlStr: string): void;
+    refreshOauth2Token(): Promise<void>;
+    getOauth1Token(ticket: string): Promise<IOauth1>;
+    getOauthClient(consumer: IOauth1Consumer): OAuth$1;
+    exchange(oauth1: IOauth1): Promise<void>;
+    setOauth2TokenExpiresAt(token: IOauth2Token): IOauth2Token;
+}
+
+interface ISportType {
+    sportTypeId: number;
+    sportTypeKey: SportTypeKey;
+}
+declare enum SportTypeKey {
+    running = "running"
+}
+interface IRunningWorkout {
+    workoutId: string | undefined;
+    description: string | undefined;
+    sportType: ISportType;
+    workoutName: string;
+    workoutSegments: IWorkoutSegment[];
+}
+interface IWorkoutSegment {
+    segmentOrder: number;
+    sportType: ISportType;
+    workoutSteps: IWorkoutStep[];
+}
+interface IWorkoutStep {
+    type: WorkoutStepType;
+    stepId: unknown;
+    stepOrder: number;
+    childStepId: unknown;
+    description: string | null;
+    stepType: IStepType;
+    endCondition: IEndCondition;
+    preferredEndConditionUnit: IPreferredEndConditionUnit;
+    endConditionValue: number | null;
+    endConditionCompare: null;
+    endConditionZone: null;
+    targetType: ITargetType;
+    targetValueOne: null;
+    targetValueTwo: null;
+    zoneNumber: null;
+}
+declare enum WorkoutStepType {
+    executableStepDTO = "ExecutableStepDTO"
+}
+interface IStepType {
+    stepTypeId: number;
+    stepTypeKey: StepTypeKey;
+}
+declare enum StepTypeKey {
+    interval = "interval"
+}
+interface IEndCondition {
+    conditionTypeKey: ConditionTypeKey;
+    conditionTypeId: number;
+}
+declare enum ConditionTypeKey {
+    distance = "distance"
+}
+interface IPreferredEndConditionUnit {
+    unitKey: UnitKey;
+}
+declare enum UnitKey {
+    kilometer = "kilometer"
+}
+interface ITargetType {
+    workoutTargetTypeId: number;
+    workoutTargetTypeKey: WorkoutTargetTypeKey;
+}
+declare enum WorkoutTargetTypeKey {
+    noTarget = "no.target"
+}
+
+declare class Running {
+    private data;
+    constructor();
+    get name(): string;
+    set name(name: string);
+    get distance(): number;
+    set distance(meters: number);
+    get workoutId(): string | undefined;
+    set workoutId(workoutId: string | undefined);
+    get description(): string | undefined;
+    set description(description: string | undefined);
+    isValid(): boolean;
+    toJson(): IRunningWorkout;
+    toString(): string;
+}
+
+interface SleepDTO {
+    id: number;
+    userProfilePK: number;
+    calendarDate: string;
+    sleepTimeSeconds: number;
+    napTimeSeconds: number;
+    sleepWindowConfirmed: boolean;
+    sleepWindowConfirmationType: string;
+    sleepStartTimestampGMT: number;
+    sleepEndTimestampGMT: number;
+    sleepStartTimestampLocal: number;
+    sleepEndTimestampLocal: number;
+    autoSleepStartTimestampGMT: number | null;
+    autoSleepEndTimestampGMT: number | null;
+    sleepQualityTypePK: number | null;
+    sleepResultTypePK: number | null;
+    unmeasurableSleepSeconds: number;
+    deepSleepSeconds: number;
+    lightSleepSeconds: number;
+    remSleepSeconds: number;
+    awakeSleepSeconds: number;
+    deviceRemCapable: boolean;
+    retro: boolean;
+    sleepFromDevice: boolean;
+    averageRespirationValue: number;
+    lowestRespirationValue: number;
+    highestRespirationValue: number;
+    awakeCount: number;
+    avgSleepStress: number;
+    ageGroup: string;
+    sleepScoreFeedback: string;
+    sleepScoreInsight: string;
+    sleepScores: {
+        totalDuration: {
+            qualifierKey: string;
+            optimalStart: number;
+            optimalEnd: number;
+        };
+        stress: {
+            qualifierKey: string;
+            optimalStart: number;
+            optimalEnd: number;
+        };
+        awakeCount: {
+            qualifierKey: string;
+            optimalStart: number;
+            optimalEnd: number;
+        };
+        overall: {
+            value: number;
+            qualifierKey: string;
+        };
+        remPercentage: {
+            value: number;
+            qualifierKey: string;
+            optimalStart: number;
+            optimalEnd: number;
+            idealStartInSeconds: number;
+            idealEndInSeconds: number;
+        };
+        restlessness: {
+            qualifierKey: string;
+            optimalStart: number;
+            optimalEnd: number;
+        };
+        lightPercentage: {
+            value: number;
+            qualifierKey: string;
+            optimalStart: number;
+            optimalEnd: number;
+            idealStartInSeconds: number;
+            idealEndInSeconds: number;
+        };
+        deepPercentage: {
+            value: number;
+            qualifierKey: string;
+            optimalStart: number;
+            optimalEnd: number;
+            idealStartInSeconds: number;
+            idealEndInSeconds: number;
+        };
+    };
+    sleepVersion: number;
+}
+interface SleepMovement {
+    startGMT: string;
+    endGMT: string;
+    activityLevel: number;
+}
+interface SleepLevels {
+    startGMT: string;
+    endGMT: string;
+    activityLevel: number;
+}
+interface WellnessEpochRespirationDataDTO {
+    startTimeGMT: number;
+    respirationValue: number;
+}
+interface SleepHeartRate {
+    value: number;
+    startGMT: number;
+}
+interface SleepBodyBattery {
+    value: number;
+    startGMT: number;
+}
+interface SleepData {
+    dailySleepDTO: SleepDTO;
+    sleepMovement: SleepMovement[];
+    remSleepData: boolean;
+    sleepLevels: SleepLevels[];
+    restlessMomentsCount: number;
+    wellnessEpochRespirationDataDTOList: WellnessEpochRespirationDataDTO[];
+    sleepHeartRate: SleepHeartRate[];
+    sleepBodyBattery: SleepBodyBattery[];
+    avgOvernightHrv: number;
+    hrvStatus: string;
+    bodyBatteryChange: number;
+    restingHeartRate: number;
+}
+
+interface DateWeight {
+    samplePk: number;
+    date: number;
+    calendarDate: string;
+    weight: number;
+    bmi: number | null;
+    bodyFat: number | null;
+    bodyWater: number | null;
+    boneMass: number | null;
+    muscleMass: number | null;
+    physiqueRating: number | null;
+    visceralFat: number | null;
+    metabolicAge: number | null;
+    sourceType: string;
+    timestampGMT: number;
+    weightDelta: number;
+}
+interface TotalAverage {
+    from: number;
+    until: number;
+    weight: number;
+    bmi: number | null;
+    bodyFat: number | null;
+    bodyWater: number | null;
+    boneMass: number | null;
+    muscleMass: number | null;
+    physiqueRating: number | null;
+    visceralFat: number | null;
+    metabolicAge: number | null;
+}
+interface WeightData {
+    startDate: string;
+    endDate: string;
+    dateWeightList: DateWeight[];
+    totalAverage: TotalAverage;
+}
+interface UpdateWeight {
+    dateTimestamp: string;
+    gmtTimestamp: string;
+    unitKey: string;
+    value: number;
+}
+
+interface WaterIntake {
+    userId: number;
+    calendarDate: string;
+    valueInML: number;
+    goalInML: number;
+    dailyAverageinML: number | null;
+    lastEntryTimestampLocal: string;
+    sweatLossInML: number | null;
+    activityIntakeInML: number;
+}
+
+interface ScorecardSummary {
+    id: number;
+    customerId: string;
+    playerProfileId: number;
+    scoreType: string;
+    courseName: string;
+    startTime: string;
+    endTime: string;
+    roundInProgress: boolean;
+    strokes: number;
+    handicappedStrokes: number;
+    scoreWithHandicap: number;
+    scoreWithoutHandicap: number;
+    holesCompleted: number;
+    roundType: string;
+}
+interface GolfSummary {
+    pageNumber: number;
+    rowsPerPage: number;
+    totalRows: number;
+    scorecardSummaries: ScorecardSummary[];
+}
+interface GolfScorecard {
+    id: number;
+    customerId: string;
+    playerProfileId: number;
+    roundPlayerName: string;
+    connectDisplayName: string;
+    courseGlobalId: number;
+    courseSnapshotId: number;
+    frontNineGlobalCourseId: number;
+    scoreType: string;
+    useHandicapScoring: boolean;
+    useStrokeCounting: boolean;
+    distanceWalked: number;
+    stepsTaken: number;
+    startTime: string;
+    formattedStartTime: string;
+    endTime: string;
+    formattedEndTime: string;
+    unitId: string;
+    roundType: string;
+    inProgress: boolean;
+    excludeFromStats: boolean;
+    holesCompleted: number;
+    publicRound: boolean;
+    score: number;
+    playerHandicap: number;
+    courseHandicapStr: string;
+    teeBox: string;
+    handicapType: string;
+    teeBoxRating: number;
+    teeBoxSlope: number;
+    lastModifiedDt: string;
+    sensorOnPutter: boolean;
+    handicappedStrokes: number;
+}
+
+interface HeartRateValueDescriptor {
+    key: string;
+    index: number;
+}
+interface HeartRateEntry {
+    timestamp: number;
+    heartrate: number;
+}
+interface HeartRate {
+    userProfilePK: number;
+    calendarDate: string;
+    startTimestampGMT: string;
+    endTimestampGMT: string;
+    startTimestampLocal: string;
+    endTimestampLocal: string;
+    maxHeartRate: number;
+    minHeartRate: number;
+    restingHeartRate: number;
+    lastSevenDaysAvgRestingHeartRate: number;
+    heartRateValueDescriptors: HeartRateValueDescriptor[];
+    heartRateValues: HeartRateEntry[][];
+}
+
+interface GCCredentials {
+    username: string;
+    password: string;
+}
+declare class GarminConnect {
+    client: HttpClient;
+    private _userHash;
+    private credentials;
+    private listeners;
+    private url;
+    constructor(credentials?: GCCredentials | undefined, domain?: GarminDomain);
+    login(username?: string, password?: string): Promise<GarminConnect>;
+    exportTokenToFile(dirPath: string): void;
+    loadTokenByFile(dirPath: string): void;
+    exportToken(): IGarminTokens;
+    loadToken(oauth1: IOauth1Token, oauth2: IOauth2Token): void;
+    getUserSettings(): Promise<IUserSettings>;
+    getUserProfile(): Promise<ISocialProfile>;
+    getActivities(start?: number, limit?: number, activityType?: ActivityType, subActivityType?: ActivitySubType): Promise<IActivity[]>;
+    getActivity(activity: {
+        activityId: GCActivityId;
+    }): Promise<IActivityDetails>;
+    countActivities(): Promise<ICountActivities>;
+    createGear(payload: {
+        createDate: Date;
+        customMakeModel: string;
+        dateBegin: Date;
+        displayName: string;
+        gearMakeName: string;
+        gearModelName: string;
+        maximumMeters: number;
+    }): Promise<Gear>;
+    getGears(userProfilePk: string | number): Promise<Gear[]>;
+    getActivityGear(activityId: string): Promise<Gear[]>;
+    linkActivityGear(gearUuid: GCGearUuid, activityId: GCActivityId): Promise<Gear>;
+    unlinkActivityGear(gearUuid: GCGearUuid, activityId: GCActivityId): Promise<Gear>;
+    changeGearStatus(userProfileId: string | number, gearUuid: GCGearUuid, data: {
+        status: GearStatus.RETIRED;
+        dateEnd: Date;
+    } | {
+        status: GearStatus.ACTIVE;
+    }): Promise<Gear>;
+    downloadOriginalActivityData(activity: {
+        activityId: GCActivityId;
+    }, dir: string, type?: ExportFileTypeValue): Promise<void>;
+    uploadActivity(file: string, format?: UploadFileTypeTypeValue): Promise<IActivityUploadDetails>;
+    getUploadActivityDetails(uploadCreationDate: string, activityId: string): Promise<IActivityUploadDetails>;
+    deleteActivity(activity: {
+        activityId: GCActivityId;
+    }): Promise<void>;
+    getWorkouts(start: number, limit: number): Promise<IWorkout[]>;
+    getWorkoutDetail(workout: {
+        workoutId: string;
+    }): Promise<IWorkoutDetail>;
+    addWorkout(workout: IWorkoutDetail | Running): Promise<IWorkoutDetail>;
+    addRunningWorkout(name: string, meters: number, description: string): Promise<IWorkoutDetail>;
+    deleteWorkout(workout: {
+        workoutId: string;
+    }): Promise<unknown>;
+    addActivity(activity: INewActivity): Promise<IActivity>;
+    getSteps(date?: Date): Promise<number>;
+    getSleepData(date?: Date): Promise<SleepData>;
+    getSleepDuration(date?: Date): Promise<{
+        hours: number;
+        minutes: number;
+    }>;
+    getDailyWeightData(date?: Date): Promise<WeightData>;
+    getDailyWeightInPounds(date?: Date): Promise<number>;
+    getDailyHydration(date?: Date): Promise<number>;
+    updateWeight(date: Date, lbs: number, timezone: string): Promise<UpdateWeight>;
+    updateHydrationLogOunces(date: Date, valueInOz: number): Promise<WaterIntake>;
+    getGolfSummary(): Promise<GolfSummary>;
+    getGolfScorecard(scorecardId: number): Promise<GolfScorecard>;
+    getHeartRate(date?: Date): Promise<HeartRate>;
+    get<T>(url: string, data?: any): Promise<T>;
+    post<T>(url: string, data: any): Promise<T>;
+    put<T>(url: string, data: any): Promise<T>;
+}
+
+export { ActivitySubType, ActivityType, GarminConnect, type Gear, GearStatus, type IActivity, type IActivityDetails };
diff --git a/dist/index.js b/dist/index.js
deleted file mode 100644
index cb15496cdef986deb117e5157aaafc230e30cd99..0000000000000000000000000000000000000000
diff --git a/dist/index.js.map b/dist/index.js.map
deleted file mode 100644
index 527f7858a51fc6d7310c68185d5ef885e10ae2b8..0000000000000000000000000000000000000000
diff --git a/dist/index.mjs b/dist/index.mjs
new file mode 100644
index 0000000000000000000000000000000000000000..d25e732c48aa0f3d692e5801e76dfab14cad9888
--- /dev/null
+++ b/dist/index.mjs
@@ -0,0 +1,1000 @@
+var __defProp = Object.defineProperty;
+var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
+
+// src/garmin/GarminConnect.ts
+import appRoot from "app-root-path";
+import FormData2 from "form-data";
+import _2 from "lodash";
+import { DateTime as DateTime2 } from "luxon";
+import * as fs from "node:fs";
+import * as path from "node:path";
+
+// src/common/HttpClient.ts
+import axios from "axios";
+import FormData from "form-data";
+import _ from "lodash";
+import { DateTime } from "luxon";
+import OAuth from "oauth-1.0a";
+import qs from "qs";
+import { createHmac } from "crypto";
+var CSRF_RE = /name="_csrf"\s+value="(.+?)"/;
+var TICKET_RE = /ticket=([^"]+)"/;
+var ACCOUNT_LOCKED_RE = /var statuss*=s*"([^"]*)"/;
+var PAGE_TITLE_RE = /<title>([^<]*)<\/title>/;
+var USER_AGENT_CONNECTMOBILE = "com.garmin.android.apps.connectmobile";
+var USER_AGENT_BROWSER = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36";
+var OAUTH_CONSUMER_URL = "https://thegarth.s3.amazonaws.com/oauth_consumer.json";
+var isRefreshing = false;
+var refreshSubscribers = [];
+var HttpClient = class {
+  static {
+    __name(this, "HttpClient");
+  }
+  constructor(url) {
+    this.url = url;
+    this.client = axios.create();
+    this.client.interceptors.response.use(
+      (response) => response,
+      async (error) => {
+        const originalRequest = error.config;
+        if (error?.response?.status === 401 && !originalRequest?._retry) {
+          if (!this.oauth2Token) {
+            return;
+          }
+          if (isRefreshing) {
+            try {
+              const token = await new Promise((resolve) => {
+                refreshSubscribers.push((token2) => {
+                  resolve(token2);
+                });
+              });
+              originalRequest.headers.Authorization = `Bearer ${token}`;
+              return this.client(originalRequest);
+            } catch (err) {
+              console.log("err:", err);
+              return Promise.reject(err);
+            }
+          }
+          originalRequest._retry = true;
+          isRefreshing = true;
+          console.log("interceptors: refreshOauth2Token start");
+          await this.refreshOauth2Token();
+          console.log("interceptors: refreshOauth2Token end");
+          isRefreshing = false;
+          refreshSubscribers.forEach((subscriber) => subscriber(this.oauth2Token.access_token));
+          refreshSubscribers = [];
+          originalRequest.headers.Authorization = `Bearer ${this.oauth2Token.access_token}`;
+          return this.client(originalRequest);
+        }
+        if (axios.isAxiosError(error)) {
+          if (error?.response) this.handleError(error?.response);
+        }
+        throw error;
+      }
+    );
+    this.client.interceptors.request.use(async (config2) => {
+      if (this.oauth2Token) {
+        config2.headers.Authorization = `Bearer ${this.oauth2Token.access_token}`;
+      }
+      return config2;
+    });
+  }
+  async fetchOauthConsumer() {
+    const response = await axios.get(OAUTH_CONSUMER_URL);
+    this.OAUTH_CONSUMER = {
+      key: response.data.consumer_key,
+      secret: response.data.consumer_secret
+    };
+  }
+  async checkTokenVaild() {
+    if (this.oauth2Token) {
+      if (this.oauth2Token.expires_at < DateTime.now().toSeconds()) {
+        console.error("Token expired!");
+        await this.refreshOauth2Token();
+      }
+    }
+  }
+  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
+  async get(url, config2) {
+    const response = await this.client.get(url, config2);
+    return response?.data;
+  }
+  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
+  async post(url, data, config2) {
+    const response = await this.client.post(url, data, config2);
+    return response?.data;
+  }
+  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
+  async put(url, data, config2) {
+    const response = await this.client.put(url, data, config2);
+    return response?.data;
+  }
+  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
+  async delete(url, config2) {
+    const response = await this.client.post(url, null, {
+      ...config2,
+      headers: {
+        ...config2?.headers,
+        "X-Http-Method-Override": "DELETE"
+      }
+    });
+    return response?.data;
+  }
+  setCommonHeader(headers) {
+    _.each(headers, (headerValue, key) => {
+      this.client.defaults.headers.common[key] = headerValue;
+    });
+  }
+  handleError(response) {
+    this.handleHttpError(response);
+  }
+  handleHttpError(response) {
+    const { status, statusText, data } = response;
+    const msg = `ERROR: (${status}), ${statusText}, ${JSON.stringify(data)}`;
+    console.error(msg);
+    throw new Error(msg);
+  }
+  /**
+   * Login to Garmin Connect
+   * @param username
+   * @param password
+   * @returns {Promise<HttpClient>}
+   */
+  async login(username, password) {
+    await this.fetchOauthConsumer();
+    const ticket = await this.getLoginTicket(username, password);
+    const oauth1 = await this.getOauth1Token(ticket);
+    await this.exchange(oauth1);
+    return this;
+  }
+  async getLoginTicket(username, password) {
+    const step1Params = {
+      clientId: "GarminConnect",
+      locale: "en",
+      service: this.url.GC_MODERN
+    };
+    const step1Url = `${this.url.GARMIN_SSO_EMBED}?${qs.stringify(step1Params)}`;
+    await this.client.get(step1Url);
+    const step2Params = {
+      id: "gauth-widget",
+      embedWidget: true,
+      locale: "en",
+      gauthHost: this.url.GARMIN_SSO_EMBED
+    };
+    const step2Url = `${this.url.SIGNIN_URL}?${qs.stringify(step2Params)}`;
+    const step2Result = await this.get(step2Url);
+    const csrfRegResult = CSRF_RE.exec(step2Result);
+    if (!csrfRegResult) {
+      throw new Error("login - csrf not found");
+    }
+    const csrf_token = csrfRegResult[1];
+    const signinParams = {
+      id: "gauth-widget",
+      embedWidget: true,
+      clientId: "GarminConnect",
+      locale: "en",
+      gauthHost: this.url.GARMIN_SSO_EMBED,
+      service: this.url.GARMIN_SSO_EMBED,
+      source: this.url.GARMIN_SSO_EMBED,
+      redirectAfterAccountLoginUrl: this.url.GARMIN_SSO_EMBED,
+      redirectAfterAccountCreationUrl: this.url.GARMIN_SSO_EMBED
+    };
+    const step3Url = `${this.url.SIGNIN_URL}?${qs.stringify(signinParams)}`;
+    const step3Form = new FormData();
+    step3Form.append("username", username);
+    step3Form.append("password", password);
+    step3Form.append("embed", "true");
+    step3Form.append("_csrf", csrf_token);
+    const step3Result = await this.post(step3Url, step3Form, {
+      headers: {
+        "Content-Type": "application/x-www-form-urlencoded",
+        Dnt: 1,
+        Origin: this.url.GARMIN_SSO_ORIGIN,
+        Referer: this.url.SIGNIN_URL,
+        "User-Agent": USER_AGENT_BROWSER
+      }
+    });
+    this.handleAccountLocked(step3Result);
+    this.handlePageTitle(step3Result);
+    this.handleMFA(step3Result);
+    const ticketRegResult = TICKET_RE.exec(step3Result);
+    if (!ticketRegResult) {
+      throw new Error("login failed (Ticket not found or MFA), please check username and password");
+    }
+    const ticket = ticketRegResult[1];
+    return ticket;
+  }
+  // TODO: Handle MFA
+  handleMFA(htmlStr) {
+  }
+  // TODO: Handle Phone number
+  handlePageTitle(htmlStr) {
+    const pageTitileRegResult = PAGE_TITLE_RE.exec(htmlStr);
+    if (pageTitileRegResult) {
+      const title = pageTitileRegResult[1];
+      console.log("login page title:", title);
+      if (_.includes(title, "Update Phone Number")) {
+        throw new Error(
+          "login failed (Update Phone number), please update your phone number, currently I don't know where to update it"
+        );
+      }
+    }
+  }
+  handleAccountLocked(htmlStr) {
+    const accountLockedRegResult = ACCOUNT_LOCKED_RE.exec(htmlStr);
+    if (accountLockedRegResult) {
+      const msg = accountLockedRegResult[1];
+      console.error(msg);
+      throw new Error("login failed (AccountLocked), please open connect web page to unlock your account");
+    }
+  }
+  async refreshOauth2Token() {
+    if (!this.OAUTH_CONSUMER) {
+      await this.fetchOauthConsumer();
+    }
+    if (!this.oauth2Token || !this.oauth1Token) {
+      throw new Error("No Oauth2Token or Oauth1Token");
+    }
+    const oauth1 = {
+      // biome-ignore lint/style/noNonNullAssertion: <explanation>
+      oauth: this.getOauthClient(this.OAUTH_CONSUMER),
+      token: this.oauth1Token
+    };
+    await this.exchange(oauth1);
+    console.log("Oauth2 token refreshed!");
+  }
+  async getOauth1Token(ticket) {
+    if (!this.OAUTH_CONSUMER) {
+      throw new Error("No OAUTH_CONSUMER");
+    }
+    const params = {
+      ticket,
+      "login-url": this.url.GARMIN_SSO_EMBED,
+      "accepts-mfa-tokens": true
+    };
+    const url = `${this.url.OAUTH_URL}/preauthorized?${qs.stringify(params)}`;
+    const oauth = this.getOauthClient(this.OAUTH_CONSUMER);
+    const step4RequestData = {
+      url,
+      method: "GET"
+    };
+    const headers = oauth.toHeader(oauth.authorize(step4RequestData));
+    const response = await this.get(url, {
+      headers: {
+        ...headers,
+        "User-Agent": USER_AGENT_CONNECTMOBILE
+      }
+    });
+    const token = qs.parse(response);
+    this.oauth1Token = token;
+    return { token, oauth };
+  }
+  getOauthClient(consumer) {
+    const oauth = new OAuth({
+      consumer,
+      signature_method: "HMAC-SHA1",
+      hash_function(base_string, key) {
+        return createHmac("sha1", key).update(base_string).digest("base64");
+      }
+    });
+    return oauth;
+  }
+  //
+  async exchange(oauth1) {
+    const token = {
+      key: oauth1.token.oauth_token,
+      secret: oauth1.token.oauth_token_secret
+    };
+    const baseUrl = `${this.url.OAUTH_URL}/exchange/user/2.0`;
+    const requestData = {
+      url: baseUrl,
+      method: "POST",
+      data: null
+    };
+    const step5AuthData = oauth1.oauth.authorize(requestData, token);
+    const url = `${baseUrl}?${qs.stringify(step5AuthData)}`;
+    this.oauth2Token = void 0;
+    const response = await this.post(url, null, {
+      headers: {
+        "User-Agent": USER_AGENT_CONNECTMOBILE,
+        "Content-Type": "application/x-www-form-urlencoded"
+      }
+    });
+    this.oauth2Token = this.setOauth2TokenExpiresAt(response);
+  }
+  setOauth2TokenExpiresAt(token) {
+    token.last_update_date = DateTime.now().toLocal().toString();
+    token.expires_date = DateTime.fromSeconds(DateTime.now().toSeconds() + token.expires_in).toLocal().toString();
+    token.expires_at = DateTime.now().toSeconds() + token.expires_in;
+    token.refresh_token_expires_at = DateTime.now().toSeconds() + token.refresh_token_expires_in;
+    return token;
+  }
+};
+
+// src/utils.ts
+import { existsSync, lstatSync, mkdirSync, writeFileSync } from "node:fs";
+var checkIsDirectory = /* @__PURE__ */ __name((filePath) => {
+  return existsSync(filePath) && lstatSync(filePath).isDirectory();
+}, "checkIsDirectory");
+var createDirectory = /* @__PURE__ */ __name((directoryPath) => {
+  mkdirSync(directoryPath);
+}, "createDirectory");
+var writeToFile = /* @__PURE__ */ __name((filePath, data) => {
+  writeFileSync(filePath, data);
+}, "writeToFile");
+
+// src/garmin/UrlClass.ts
+var UrlClass = class {
+  static {
+    __name(this, "UrlClass");
+  }
+  constructor(domain = "garmin.com") {
+    this.domain = domain;
+    this.GC_MODERN = `https://connect.${this.domain}/modern`;
+    this.GARMIN_SSO_ORIGIN = `https://sso.${this.domain}`;
+    this.GC_API = `https://connectapi.${this.domain}`;
+  }
+  get GARMIN_SSO() {
+    return `${this.GARMIN_SSO_ORIGIN}/sso`;
+  }
+  get GARMIN_SSO_EMBED() {
+    return `${this.GARMIN_SSO_ORIGIN}/sso/embed`;
+  }
+  get BASE_URL() {
+    return `${this.GC_MODERN}/proxy`;
+  }
+  get SIGNIN_URL() {
+    return `${this.GARMIN_SSO}/signin`;
+  }
+  get LOGIN_URL() {
+    return `${this.GARMIN_SSO}/login`;
+  }
+  get OAUTH_URL() {
+    return `${this.GC_API}/oauth-service/oauth`;
+  }
+  get USER_SETTINGS() {
+    return `${this.GC_API}/userprofile-service/userprofile/user-settings/`;
+  }
+  get USER_PROFILE() {
+    return `${this.GC_API}/userprofile-service/socialProfile`;
+  }
+  get ACTIVITIES() {
+    return `${this.GC_API}/activitylist-service/activities/search/activities`;
+  }
+  get ACTIVITY() {
+    return `${this.GC_API}/activity-service/activity/`;
+  }
+  get STAT_ACTIVITIES() {
+    return `${this.GC_API}/fitnessstats-service/activity`;
+  }
+  get CREATE_GEAR() {
+    return `${this.GC_API}/gear-service/gear`;
+  }
+  get ACTIVITY_GEAR() {
+    return `${this.GC_API}/gear-service/gear/filterGear`;
+  }
+  GEAR_DATA(gearId) {
+    return `${this.GC_API}/gear-service/gear/${gearId}`;
+  }
+  ACTIVITY_GEAR_LINK(gearId, activityId) {
+    return `${this.GC_API}/gear-service/gear/link/${gearId}/activity/${activityId}`;
+  }
+  ACTIVITY_GEAR_UNLINK(gearId, activityId) {
+    return `${this.GC_API}/gear-service/gear/unlink/${gearId}/activity/${activityId}`;
+  }
+  get DOWNLOAD_ZIP() {
+    return `${this.GC_API}/download-service/files/activity/`;
+  }
+  get DOWNLOAD_GPX() {
+    return `${this.GC_API}/download-service/export/gpx/activity/`;
+  }
+  get DOWNLOAD_TCX() {
+    return `${this.GC_API}/download-service/export/tcx/activity/`;
+  }
+  get DOWNLOAD_KML() {
+    return `${this.GC_API}/download-service/export/kml/activity/`;
+  }
+  UPLOAD(format) {
+    return `${this.GC_API}/upload-service/upload/.${format}`;
+  }
+  UPLOAD_ACTIVITY_STATUS(uploadTime, activityId) {
+    return `${this.GC_API}/activity-service/activity/status/${uploadTime}/${activityId}`;
+  }
+  get IMPORT_DATA() {
+    return `${this.GC_API}/modern/import-data`;
+  }
+  get DAILY_STEPS() {
+    return `${this.GC_API}/usersummary-service/stats/steps/daily/`;
+  }
+  get DAILY_SLEEP() {
+    return `${this.GC_API}/sleep-service/sleep/dailySleepData`;
+  }
+  get DAILY_WEIGHT() {
+    return `${this.GC_API}/weight-service/weight/dayview`;
+  }
+  get UPDATE_WEIGHT() {
+    return `${this.GC_API}/weight-service/user-weight`;
+  }
+  get DAILY_HYDRATION() {
+    return `${this.GC_API}/usersummary-service/usersummary/hydration/allData`;
+  }
+  get HYDRATION_LOG() {
+    return `${this.GC_API}/usersummary-service/usersummary/hydration/log`;
+  }
+  get GOLF_SCORECARD_SUMMARY() {
+    return `${this.GC_API}/gcs-golfcommunity/api/v2/scorecard/summary`;
+  }
+  get GOLF_SCORECARD_DETAIL() {
+    return `${this.GC_API}/gcs-golfcommunity/api/v2/scorecard/detail`;
+  }
+  get DAILY_HEART_RATE() {
+    return `${this.GC_API}/wellness-service/wellness/dailyHeartRate`;
+  }
+  WORKOUT(id) {
+    if (id) {
+      return `${this.GC_API}/workout-service/workout/${id}`;
+    }
+    return `${this.GC_API}/workout-service/workout`;
+  }
+  get WORKOUTS() {
+    return `${this.GC_API}/workout-service/workouts`;
+  }
+};
+
+// src/garmin/types/index.ts
+var UploadFileType = /* @__PURE__ */ ((UploadFileType2) => {
+  UploadFileType2["tcx"] = "tcx";
+  UploadFileType2["gpx"] = "gpx";
+  UploadFileType2["fit"] = "fit";
+  return UploadFileType2;
+})(UploadFileType || {});
+var GearStatus = /* @__PURE__ */ ((GearStatus2) => {
+  GearStatus2["ACTIVE"] = "active";
+  GearStatus2["RETIRED"] = "retired";
+  return GearStatus2;
+})(GearStatus || {});
+
+// src/garmin/workouts/templates/RunningTemplate.ts
+function RunningTemplate_default() {
+  return {
+    description: void 0,
+    workoutId: void 0,
+    sportType: {
+      sportTypeId: 1,
+      sportTypeKey: "running" /* running */
+    },
+    workoutName: "",
+    workoutSegments: [
+      {
+        segmentOrder: 1,
+        sportType: {
+          sportTypeId: 1,
+          sportTypeKey: "running" /* running */
+        },
+        workoutSteps: [
+          {
+            type: "ExecutableStepDTO" /* executableStepDTO */,
+            stepId: null,
+            stepOrder: 1,
+            childStepId: null,
+            description: null,
+            stepType: {
+              stepTypeId: 3,
+              stepTypeKey: "interval" /* interval */
+            },
+            endCondition: {
+              conditionTypeKey: "distance" /* distance */,
+              conditionTypeId: 3
+            },
+            preferredEndConditionUnit: {
+              unitKey: "kilometer" /* kilometer */
+            },
+            endConditionValue: null,
+            endConditionCompare: null,
+            endConditionZone: null,
+            targetType: {
+              workoutTargetTypeId: 1,
+              workoutTargetTypeKey: "no.target" /* noTarget */
+            },
+            targetValueOne: null,
+            targetValueTwo: null,
+            zoneNumber: null
+          }
+        ]
+      }
+    ]
+  };
+}
+__name(RunningTemplate_default, "default");
+
+// src/garmin/workouts/Running.ts
+var Running = class {
+  static {
+    __name(this, "Running");
+  }
+  constructor() {
+    this.data = RunningTemplate_default();
+  }
+  get name() {
+    return this.data.workoutName;
+  }
+  set name(name) {
+    this.data.workoutName = `${name}`;
+  }
+  get distance() {
+    return this.data.workoutSegments[0].workoutSteps[0].endConditionValue || 0;
+  }
+  set distance(meters) {
+    this.data.workoutSegments[0].workoutSteps[0].endConditionValue = Math.round(meters);
+  }
+  get workoutId() {
+    return this.data.workoutId;
+  }
+  set workoutId(workoutId) {
+    this.data.workoutId = workoutId;
+  }
+  get description() {
+    return this.data.description;
+  }
+  set description(description) {
+    this.data.description = description;
+  }
+  isValid() {
+    return !!(this.name && this.distance);
+  }
+  toJson() {
+    return this.data;
+  }
+  toString() {
+    return `${this.name}, ${(this.distance / 1e3).toFixed(2)}km`;
+  }
+};
+
+// src/garmin/common/DateUtils.ts
+function toDateString(date) {
+  const offset = date.getTimezoneOffset();
+  const offsetDate = new Date(date.getTime() - offset * 60 * 1e3);
+  const [dateString] = offsetDate.toISOString().split("T");
+  return dateString;
+}
+__name(toDateString, "toDateString");
+function calculateTimeDifference(sleepStartTimestampGMT, sleepEndTimestampGMT) {
+  const timeDifferenceInSeconds = (sleepEndTimestampGMT - sleepStartTimestampGMT) / 1e3;
+  const hours = Math.floor(timeDifferenceInSeconds / 3600);
+  const minutes = Math.floor(timeDifferenceInSeconds % 3600 / 60);
+  return {
+    hours,
+    minutes
+  };
+}
+__name(calculateTimeDifference, "calculateTimeDifference");
+function getLocalTimestamp(date, timezone) {
+  const localTimestampISO = date.toISOString().substring(0, 23);
+  const localTimestamp = new Date(localTimestampISO).toLocaleString("en-US", {
+    timeZone: timezone,
+    hour12: false
+  });
+  const formattedLocalTimestamp = new Date(localTimestamp).toISOString().substring(0, 23);
+  return formattedLocalTimestamp;
+}
+__name(getLocalTimestamp, "getLocalTimestamp");
+
+// src/garmin/common/WeightUtils.ts
+function gramsToPounds(weightInGrams) {
+  const gramsPerPound = 453.592;
+  return weightInGrams / gramsPerPound;
+}
+__name(gramsToPounds, "gramsToPounds");
+
+// src/garmin/common/HydrationUtils.ts
+function convertMLToOunces(valueInML) {
+  const conversionFactor = 0.033814;
+  const valueInOunces = valueInML * conversionFactor;
+  return valueInOunces;
+}
+__name(convertMLToOunces, "convertMLToOunces");
+function convertOuncesToML(ounces) {
+  const ouncesToMillilitersConversionFactor = 29.5735;
+  const milliliters = ounces * ouncesToMillilitersConversionFactor;
+  return milliliters;
+}
+__name(convertOuncesToML, "convertOuncesToML");
+
+// src/garmin/GarminConnect.ts
+var config = void 0;
+try {
+  config = appRoot.require("/garmin.config.json");
+} catch (e) {
+}
+var GarminConnect = class {
+  static {
+    __name(this, "GarminConnect");
+  }
+  // private oauth1: OAuth;
+  constructor(credentials = config, domain = "garmin.com") {
+    if (!credentials) {
+      throw new Error("Missing credentials");
+    }
+    this.credentials = credentials;
+    this.url = new UrlClass(domain);
+    this.client = new HttpClient(this.url);
+    this._userHash = void 0;
+    this.listeners = {};
+  }
+  async login(username, password) {
+    if (username && password) {
+      this.credentials.username = username;
+      this.credentials.password = password;
+    }
+    await this.client.login(this.credentials.username, this.credentials.password);
+    return this;
+  }
+  exportTokenToFile(dirPath) {
+    if (!checkIsDirectory(dirPath)) {
+      createDirectory(dirPath);
+    }
+    if (this.client.oauth1Token) {
+      writeToFile(path.join(dirPath, "oauth1_token.json"), JSON.stringify(this.client.oauth1Token));
+    }
+    if (this.client.oauth2Token) {
+      writeToFile(path.join(dirPath, "oauth2_token.json"), JSON.stringify(this.client.oauth2Token));
+    }
+  }
+  loadTokenByFile(dirPath) {
+    if (!checkIsDirectory(dirPath)) {
+      throw new Error(`loadTokenByFile: Directory not found: ${dirPath}`);
+    }
+    const oauth1Data = fs.readFileSync(path.join(dirPath, "oauth1_token.json"));
+    this.client.oauth1Token = JSON.parse(oauth1Data);
+    const oauth2Data = fs.readFileSync(path.join(dirPath, "oauth2_token.json"));
+    this.client.oauth2Token = JSON.parse(oauth2Data);
+  }
+  exportToken() {
+    if (!this.client.oauth1Token || !this.client.oauth2Token) {
+      throw new Error("exportToken: Token not found");
+    }
+    return {
+      oauth1: this.client.oauth1Token,
+      oauth2: this.client.oauth2Token
+    };
+  }
+  // from db or localstorage etc
+  loadToken(oauth1, oauth2) {
+    this.client.oauth1Token = oauth1;
+    this.client.oauth2Token = oauth2;
+  }
+  getUserSettings() {
+    return this.client.get(this.url.USER_SETTINGS);
+  }
+  getUserProfile() {
+    return this.client.get(this.url.USER_PROFILE);
+  }
+  getActivities(start, limit, activityType, subActivityType) {
+    return this.client.get(this.url.ACTIVITIES, {
+      params: { start, limit, activityType, subActivityType }
+    });
+  }
+  getActivity(activity) {
+    if (!activity.activityId) throw new Error("Missing activityId");
+    return this.client.get(this.url.ACTIVITY + activity.activityId);
+  }
+  countActivities() {
+    return this.client.get(this.url.STAT_ACTIVITIES, {
+      params: {
+        aggregation: "lifetime",
+        startDate: "1970-01-01",
+        endDate: DateTime2.now().toFormat("yyyy-MM-dd"),
+        metric: "duration"
+      }
+    });
+  }
+  createGear(payload) {
+    return this.client.post(this.url.CREATE_GEAR, {
+      createDate: payload.createDate.toISOString(),
+      customMakeModel: payload.customMakeModel,
+      dateBegin: payload.dateBegin.toISOString(),
+      displayName: payload.displayName,
+      gearMakeName: payload.gearMakeName,
+      gearModelName: payload.gearModelName,
+      gearStatusName: "active",
+      maximumMeters: payload.maximumMeters
+    });
+  }
+  getGears(userProfilePk) {
+    return this.client.get(this.url.ACTIVITY_GEAR, {
+      params: {
+        userProfilePk
+      }
+    });
+  }
+  getActivityGear(activityId) {
+    return this.client.get(this.url.ACTIVITY_GEAR, {
+      params: {
+        activityId
+      }
+    });
+  }
+  linkActivityGear(gearUuid, activityId) {
+    return this.client.put(this.url.ACTIVITY_GEAR_LINK(gearUuid, activityId), {});
+  }
+  unlinkActivityGear(gearUuid, activityId) {
+    return this.client.put(this.url.ACTIVITY_GEAR_UNLINK(gearUuid, activityId), {});
+  }
+  async changeGearStatus(userProfileId, gearUuid, data) {
+    const gears = await this.getGears(userProfileId);
+    const gear = gears.find((g) => g.uuid === gearUuid);
+    if (!gear) {
+      throw new Error(`changeGearStatus: Gear with uuid ${gearUuid} not found`);
+    }
+    if (gear.gearStatusName === data.status) {
+      throw new Error(`changeGearStatus: Gear already has status ${data.status}`);
+    }
+    return this.client.put(this.url.GEAR_DATA(gearUuid), {
+      ...gear,
+      gearStatusName: data.status,
+      ...data.status === "retired" /* RETIRED */ ? { dateEnd: data.dateEnd.toISOString() } : {
+        dateEnd: null
+      }
+    });
+  }
+  async downloadOriginalActivityData(activity, dir, type = "zip") {
+    if (!activity.activityId) throw new Error("Missing activityId");
+    if (!checkIsDirectory(dir)) {
+      createDirectory(dir);
+    }
+    let fileBuffer;
+    if (type === "tcx") {
+      fileBuffer = await this.client.get(this.url.DOWNLOAD_TCX + activity.activityId);
+    } else if (type === "gpx") {
+      fileBuffer = await this.client.get(this.url.DOWNLOAD_GPX + activity.activityId);
+    } else if (type === "kml") {
+      fileBuffer = await this.client.get(this.url.DOWNLOAD_KML + activity.activityId);
+    } else if (type === "zip") {
+      fileBuffer = await this.client.get(this.url.DOWNLOAD_ZIP + activity.activityId, {
+        responseType: "arraybuffer"
+      });
+    } else {
+      throw new Error(`downloadOriginalActivityData - Invalid type: ${type}`);
+    }
+    writeToFile(path.join(dir, `${activity.activityId}.${type}`), fileBuffer);
+  }
+  uploadActivity(file, format = "fit") {
+    const detectedFormat = (format || path.extname(file))?.toLowerCase();
+    if (!_2.includes(UploadFileType, detectedFormat)) {
+      throw new Error(`uploadActivity - Invalid format: ${format}`);
+    }
+    const fileBuffer = fs.createReadStream(file);
+    const form = new FormData2();
+    form.append("userfile", fileBuffer);
+    return this.client.post(this.url.UPLOAD(format), form, {
+      headers: {
+        "Content-Type": form.getHeaders()["content-type"]
+      }
+    });
+  }
+  getUploadActivityDetails(uploadCreationDate, activityId) {
+    const creationDate = new Date(uploadCreationDate);
+    return this.client.get(this.url.UPLOAD_ACTIVITY_STATUS(creationDate.getTime(), activityId));
+  }
+  deleteActivity(activity) {
+    if (!activity.activityId) throw new Error("Missing activityId");
+    return this.client.delete(this.url.ACTIVITY + activity.activityId);
+  }
+  getWorkouts(start, limit) {
+    return this.client.get(this.url.WORKOUTS, {
+      params: {
+        start,
+        limit
+      }
+    });
+  }
+  getWorkoutDetail(workout) {
+    if (!workout.workoutId) throw new Error("Missing workoutId");
+    return this.client.get(this.url.WORKOUT(workout.workoutId));
+  }
+  addWorkout(workout) {
+    if (!workout) throw new Error("Missing workout");
+    if (workout instanceof Running) {
+      if (workout.isValid()) {
+        const data = { ...workout.toJson() };
+        if (!data.description) {
+          data.description = "Added by garmin-connect for Node.js";
+        }
+        return this.client.post(this.url.WORKOUT(), data);
+      }
+    }
+    const newWorkout = _2.omit(workout, ["workoutId", "ownerId", "updatedDate", "createdDate", "author"]);
+    if (!newWorkout.description) {
+      newWorkout.description = "Added by garmin-connect for Node.js";
+    }
+    return this.client.post(this.url.WORKOUT(), newWorkout);
+  }
+  addRunningWorkout(name, meters, description) {
+    const running = new Running();
+    running.name = name;
+    running.distance = meters;
+    running.description = description;
+    return this.addWorkout(running);
+  }
+  deleteWorkout(workout) {
+    if (!workout.workoutId) throw new Error("Missing workout");
+    return this.client.delete(this.url.WORKOUT(workout.workoutId));
+  }
+  addActivity(activity) {
+    return this.client.post(this.url.ACTIVITY, activity);
+  }
+  async getSteps(date = /* @__PURE__ */ new Date()) {
+    const dateString = toDateString(date);
+    const days = await this.client.get(`${this.url.DAILY_STEPS}${dateString}/${dateString}`);
+    const dayStats = days.find(({ calendarDate }) => calendarDate === dateString);
+    if (!dayStats) {
+      throw new Error("Can't find daily steps for this date.");
+    }
+    return dayStats.totalSteps;
+  }
+  async getSleepData(date = /* @__PURE__ */ new Date()) {
+    try {
+      const dateString = toDateString(date);
+      const sleepData = await this.client.get(`${this.url.DAILY_SLEEP}`, { params: { date: dateString } });
+      if (!sleepData) {
+        throw new Error("Invalid or empty sleep data response.");
+      }
+      return sleepData;
+    } catch (error) {
+      throw new Error(`Error in getSleepData: ${error.message}`);
+    }
+  }
+  async getSleepDuration(date = /* @__PURE__ */ new Date()) {
+    try {
+      const sleepData = await this.getSleepData(date);
+      if (!sleepData || !sleepData.dailySleepDTO || sleepData.dailySleepDTO.sleepStartTimestampGMT === void 0 || sleepData.dailySleepDTO.sleepEndTimestampGMT === void 0) {
+        throw new Error("Invalid or missing sleep data for the specified date.");
+      }
+      const sleepStartTimestampGMT = sleepData.dailySleepDTO.sleepStartTimestampGMT;
+      const sleepEndTimestampGMT = sleepData.dailySleepDTO.sleepEndTimestampGMT;
+      const { hours, minutes } = calculateTimeDifference(sleepStartTimestampGMT, sleepEndTimestampGMT);
+      return {
+        hours,
+        minutes
+      };
+    } catch (error) {
+      throw new Error(`Error in getSleepDuration: ${error.message}`);
+    }
+  }
+  async getDailyWeightData(date = /* @__PURE__ */ new Date()) {
+    try {
+      const dateString = toDateString(date);
+      const weightData = await this.client.get(`${this.url.DAILY_WEIGHT}/${dateString}`);
+      if (!weightData) {
+        throw new Error("Invalid or empty weight data response.");
+      }
+      return weightData;
+    } catch (error) {
+      throw new Error(`Error in getDailyWeightData: ${error.message}`);
+    }
+  }
+  async getDailyWeightInPounds(date = /* @__PURE__ */ new Date()) {
+    const weightData = await this.getDailyWeightData(date);
+    if (weightData.totalAverage && typeof weightData.totalAverage.weight === "number") {
+      return gramsToPounds(weightData.totalAverage.weight);
+    }
+    throw new Error("Can't find valid daily weight for this date.");
+  }
+  async getDailyHydration(date = /* @__PURE__ */ new Date()) {
+    try {
+      const dateString = toDateString(date);
+      const hydrationData = await this.client.get(`${this.url.DAILY_HYDRATION}/${dateString}`);
+      if (!hydrationData || !hydrationData.valueInML) {
+        throw new Error("Invalid or empty hydration data response.");
+      }
+      return convertMLToOunces(hydrationData.valueInML);
+    } catch (error) {
+      throw new Error(`Error in getDailyHydration: ${error.message}`);
+    }
+  }
+  async updateWeight(date, lbs, timezone) {
+    try {
+      const weightData = await this.client.post(`${this.url.UPDATE_WEIGHT}`, {
+        dateTimestamp: getLocalTimestamp(date, timezone),
+        gmtTimestamp: date.toISOString().substring(0, 23),
+        unitKey: "lbs",
+        value: lbs
+      });
+      return weightData;
+    } catch (error) {
+      throw new Error(`Error in updateWeight: ${error.message}`);
+    }
+  }
+  async updateHydrationLogOunces(date, valueInOz) {
+    try {
+      const dateString = toDateString(date);
+      const hydrationData = await this.client.put(`${this.url.HYDRATION_LOG}`, {
+        calendarDate: dateString,
+        valueInML: convertOuncesToML(valueInOz),
+        userProfileId: (await this.getUserProfile()).profileId,
+        timestampLocal: date.toISOString().substring(0, 23)
+      });
+      return hydrationData;
+    } catch (error) {
+      throw new Error(`Error in updateHydrationLogOunces: ${error.message}`);
+    }
+  }
+  async getGolfSummary() {
+    try {
+      const golfSummary = await this.client.get(`${this.url.GOLF_SCORECARD_SUMMARY}`);
+      if (!golfSummary) {
+        throw new Error("Invalid or empty golf summary data response.");
+      }
+      return golfSummary;
+    } catch (error) {
+      throw new Error(`Error in getGolfSummary: ${error.message}`);
+    }
+  }
+  async getGolfScorecard(scorecardId) {
+    try {
+      const golfScorecard = await this.client.get(`${this.url.GOLF_SCORECARD_DETAIL}`, {
+        params: { "scorecard-ids": scorecardId }
+      });
+      if (!golfScorecard) {
+        throw new Error("Invalid or empty golf scorecard data response.");
+      }
+      return golfScorecard;
+    } catch (error) {
+      throw new Error(`Error in getGolfScorecard: ${error.message}`);
+    }
+  }
+  async getHeartRate(date = /* @__PURE__ */ new Date()) {
+    try {
+      const dateString = toDateString(date);
+      const heartRate = await this.client.get(`${this.url.DAILY_HEART_RATE}`, {
+        params: { date: dateString }
+      });
+      return heartRate;
+    } catch (error) {
+      throw new Error(`Error in getHeartRate: ${error.message}`);
+    }
+  }
+  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
+  get(url, data) {
+    return this.client.get(url, data);
+  }
+  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
+  post(url, data) {
+    return this.client.post(url, data, {});
+  }
+  // biome-ignore lint/suspicious/noExplicitAny: <explanation>
+  put(url, data) {
+    return this.client.put(url, data, {});
+  }
+};
+
+// src/garmin/types/activity.ts
+var ActivityType = /* @__PURE__ */ ((ActivityType2) => {
+  ActivityType2["Cycling"] = "cycling";
+  ActivityType2["FitnessEquipment"] = "fitness_equipment";
+  ActivityType2["Walking"] = "walking";
+  ActivityType2["Hiking"] = "hiking";
+  ActivityType2["Other"] = "other";
+  ActivityType2["WaterSport"] = "water_sports";
+  ActivityType2["Running"] = "running";
+  return ActivityType2;
+})(ActivityType || {});
+var ActivitySubType = /* @__PURE__ */ ((ActivitySubType2) => {
+  ActivitySubType2["IndoorCardio"] = "indoor_cardio";
+  ActivitySubType2["StrengthTraining"] = "strength_training";
+  ActivitySubType2["HIIT"] = "hiit";
+  ActivitySubType2["Yoga"] = "yoga";
+  ActivitySubType2["IndoorCycling"] = "indoor_cycling";
+  ActivitySubType2["Breathwork"] = "breathwork";
+  ActivitySubType2["Surfing"] = "surfing";
+  ActivitySubType2["StreetRunning"] = "street_running";
+  ActivitySubType2["TrailRunning"] = "trail_running";
+  ActivitySubType2["IndoorRunning"] = "indoor_running";
+  return ActivitySubType2;
+})(ActivitySubType || {});
+export {
+  ActivitySubType,
+  ActivityType,
+  GarminConnect,
+  GearStatus
+};
diff --git a/dist/utils.d.ts b/dist/utils.d.ts
deleted file mode 100644
index 4820583329294f68632fc26b3dbbcac8055546b8..0000000000000000000000000000000000000000
diff --git a/dist/utils.js b/dist/utils.js
deleted file mode 100644
index 47390dd85356206d08bc3dc93d6a4a3d05f9048c..0000000000000000000000000000000000000000
diff --git a/dist/utils.js.map b/dist/utils.js.map
deleted file mode 100644
index 73f1926b57c54e3e0680ecafe8366ccea2d56476..0000000000000000000000000000000000000000
diff --git a/examples/example.js b/examples/example.js
deleted file mode 100644
index 4547d332f1c56a5e0ab3f06d8e2f50270f2fd674..0000000000000000000000000000000000000000
diff --git a/package.json b/package.json
index 06eabeef1ec6debb29601449aa975aed25943e15..a2a3864d3ddf6b05adc4fb97fa5fee347339eeec 100644
--- a/package.json
+++ b/package.json
@@ -1,66 +1,75 @@
 {
-    "name": "garmin-connect",
-    "version": "1.6.2",
-    "description": "Makes it simple to interface with Garmin Connect to get or set any data point",
-    "main": "./dist/index.js",
-    "types": "./dist/index.d.ts",
-    "scripts": {
-        "build": "tsc --build --clean && find ./dist -type d -empty -delete; tsc",
-        "build:windows": "tsc --build --clean && tsc",
-        "build:watch": "npm run build -- --watch",
-        "build:watch-windows": "npm run build:windows -- --watch",
-        "prettier:all": "prettier --write .",
-        "pretty": "pretty-quick --staged",
-        "prepack": "npm run build"
+  "name": "garmin-connect",
+  "version": "1.6.2",
+  "description": "Makes it simple to interface with Garmin Connect to get or set any data point",
+  "type": "module",
+  "types": "dist/index.d.ts",
+  "exports": {
+    ".": {
+      "import": {
+        "types": "./dist/index.d.ts",
+        "default": "./dist/index.mjs"
+      },
+      "require": {
+        "types": "./dist/index.d.cts",
+        "default": "./dist/index.cjs"
+      },
+      "default": "./dist/index.mjs"
     },
-    "repository": {
-        "type": "git",
-        "url": "git+https://github.com/Pythe1337N/garmin-connect.git"
-    },
-    "keywords": [
-        "garmin",
-        "connect",
-        "scraper",
-        "weight",
-        "running",
-        "workout",
-        "activity",
-        "activities",
-        "download",
-        "downloader"
-    ],
-    "author": "Oskar Bernberg (Pythe1337N)",
-    "license": "MIT",
-    "files": [
-        "dist/*",
-        "examples/*"
-    ],
-    "devDependencies": {
-        "@types/app-root-path": "^1.2.4",
-        "@types/lodash": "^4.14.199",
-        "@types/luxon": "^3.3.2",
-        "@types/node": "^18.11.15",
-        "@types/qs": "^6.9.7",
-        "@types/request-promise": "^4.1.48",
-        "pre-commit": "^1.2.2",
-        "prettier": "^2.8.1",
-        "pretty-quick": "^3.1.3",
-        "typescript": "^4.9.4"
-    },
-    "homepage": "https://github.com/Pythe1337N/garmin-connect#readme",
-    "bugs": {
-        "url": "https://github.com/Pythe1337N/garmin-connect/issues"
-    },
-    "runkitExampleFilename": "./examples/example.js",
-    "dependencies": {
-        "app-root-path": "^3.1.0",
-        "axios": "^1.5.1",
-        "crypto": "^1.0.1",
-        "form-data": "^4.0.0",
-        "lodash": "^4.17.21",
-        "luxon": "^3.4.3",
-        "oauth-1.0a": "^2.2.6",
-        "qs": "^6.11.2"
-    },
-    "pre-commit": "pretty"
+    "./dist/*": {
+      "types": "./dist/*.d.ts",
+      "import": "./dist/*.mjs",
+      "require": "./dist/*.cjs"
+    }
+  },
+  "scripts": {
+    "build": "tsup",
+    "format:check": "biome format src",
+    "format:fix": "biome format --write src",
+    "prepare": "npm run build"
+  },
+  "repository": {
+    "type": "git",
+    "url": "git+https://github.com/jmn8718/garmin-connect.git"
+  },
+  "keywords": [
+    "garmin",
+    "connect",
+    "scraper",
+    "weight",
+    "running",
+    "workout",
+    "activity",
+    "activities",
+    "download",
+    "downloader"
+  ],
+  "author": "Oskar Bernberg (Pythe1337N)",
+  "license": "MIT",
+  "files": ["dist/*"],
+  "devDependencies": {
+    "@biomejs/biome": "1.9.4",
+    "@types/app-root-path": "1.2.4",
+    "@types/lodash": "4.14.199",
+    "@types/luxon": "3.3.2",
+    "@types/node": "18.11.15",
+    "@types/qs": "6.9.7",
+    "@types/request-promise": "4.1.48",
+    "tsup": "8.4.0",
+    "typescript": "5.7.2"
+  },
+  "homepage": "https://github.com/Pythe1337N/garmin-connect#readme",
+  "bugs": {
+    "url": "https://github.com/Pythe1337N/garmin-connect/issues"
+  },
+  "dependencies": {
+    "app-root-path": "3.1.0",
+    "axios": "1.5.1",
+    "crypto": "1.0.1",
+    "form-data": "4.0.0",
+    "lodash": "4.17.21",
+    "luxon": "3.4.3",
+    "oauth-1.0a": "2.2.6",
+    "qs": "6.11.2"
+  }
 }
